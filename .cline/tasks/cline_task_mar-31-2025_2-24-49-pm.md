**User:**

<task>
ç•«é¢ä¸€é–‹å§‹æ²’æœ‰ç”¢ç”Ÿä»»ä½•éŠå®¢ï¼Œè«‹ç¢ºèª
</task>
<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/visitorConfigSlice.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 2:12:35 PM (Asia/Taipei, UTC+8:00)

# Current Working Directory (/home/ben/github.com/theme-park-simulator) Files
ğŸ”’ .clineignore
.clinerules
.gitignore
eslint.config.js
index.html
jest.config.ts
jest.setup.ts
package-lock.json
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.test.json
vite.config.ts
cypress/
cypress/fixtures/
cypress/support/
memory-bank/
memory-bank/01_projectbrief.md
memory-bank/02_productContext.md
memory-bank/03_systemPatterns.md
memory-bank/04_techContext.md
memory-bank/05_activeContext.md
memory-bank/06_progress.md
public/
public/vite.svg
src/
src/App.css
src/App.tsx
src/index.css
src/main.tsx
src/vite-env.d.ts
src/assets/
src/assets/react.svg
src/components/
src/components/game/
src/components/game/Facility.ts
src/components/game/FacilityBuilder.ts
src/components/game/GameCanvas.tsx
src/components/game/Visitor.ts
src/components/game/__tests__/
src/components/game/__tests__/Facility.test.ts
src/components/game/__tests__/FacilityBuilder.test.ts
src/components/game/__tests__/Visitor.test.ts
src/components/game/__tests__/Visitor.test.ts.bak
src/components/game/types/
src/components/game/types/FacilityTypes.ts
src/components/game/types/MapConfig.ts
src/components/shared/
src/components/shared/ErrorMessage.css
src/components/shared/ErrorMessage.tsx
src/components/shared/LoadingSpinner.css
src/components/shared/LoadingSpinner.tsx
src/components/shared/Transition.css
src/components/shared/TransitionWrapper.tsx
src/components/ui/
src/components/ui/FacilityBuilderPanel.css
src/components/ui/FacilityBuilderPanel.tsx
src/components/ui/VisitorConfigPanel.tsx
src/components/ui/VisitorInfoPanel.tsx
src/components/ui/__tests__/
src/components/ui/__tests__/FacilityBuilderPanel.test.tsx
src/components/ui/__tests__/VisitorConfigPanel.test.tsx
src/components/ui/__tests__/VisitorInfoPanel.test.tsx
src/engine/
src/hooks/
src/hooks/useAppDispatch.ts
src/hooks/useAppSelector.ts
src/store/
src/store/facilitySlice.ts
src/store/index.ts
src/store/visitorConfigSlice.ts
src/store/visitorSlice.ts
src/types/
src/utils/
src/utils/PathFinder.ts
src/utils/SatisfactionManager.ts
src/utils/__tests__/
src/utils/__tests__/PathFinder.test.ts
src/utils/__tests__/SatisfactionManager.test.ts
tests/
tests/dialog-demo/
tests/dialog-demo/.gitignore
tests/dialog-demo/cypress.config.mjs
tests/dialog-demo/eslint.config.js
tests/dialog-demo/index.html
tests/dialog-demo/package-lock.json
tests/dialog-demo/package.json
tests/dialog-demo/README.md
tests/dialog-demo/tsconfig.app.json
tests/dialog-demo/tsconfig.json
tests/dialog-demo/tsconfig.node.json
tests/dialog-demo/vite.config.ts
tests/dialog-demo/cypress/
tests/dialog-demo/cypress/e2e/
tests/dialog-demo/cypress/e2e/dialog.cy.ts
tests/dialog-demo/cypress/snapshots/
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/dialog-shown.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/initial-state.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/message-1.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/message-2.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/message-3.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/typing-state.png
tests/dialog-demo/cypress/support/
tests/dialog-demo/cypress/support/e2e.ts
tests/dialog-demo/public/
tests/dialog-demo/public/vite.svg
tests/dialog-demo/src/
tests/dialog-demo/src/App.css
tests/dialog-demo/src/App.tsx
tests/dialog-demo/src/index.css
tests/dialog-demo/src/main.tsx
tests/dialog-demo/src/vite-env.d.ts
tests/dialog-demo/src/assets/
tests/dialog-demo/src/assets/react.svg
tests/dialog-demo/src/components/
tests/dialog-demo/src/components/game/
tests/dialog-demo/src/components/game/GameCanvas.tsx
tests/dialog-demo/src/components/ui/
tests/dialog-demo/src/components/ui/DialogInput.tsx
tests/dialog-demo/src/hooks/
tests/dialog-demo/src/hooks/useAppDispatch.ts
tests/dialog-demo/src/hooks/useAppSelector.ts
tests/dialog-demo/src/store/
tests/dialog-demo/src/store/dialogSlice.ts
tests/dialog-demo/src/store/index.ts
tests/dialog-demo/src/utils/

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
è®“æˆ‘æª¢æŸ¥éŠå®¢ç”Ÿæˆç›¸é—œçš„ä»£ç¢¼ã€‚é¦–å…ˆçœ‹çœ‹ visitorConfigSlice å’Œ visitorSlice çš„å…§å®¹ä¾†ç¢ºèªéŠå®¢ç”Ÿæˆçš„é‚è¼¯ã€‚
</thinking>

<read_file>
<path>src/store/visitorConfigSlice.ts</path>
</read_file>

---

**User:**

[read_file for 'src/store/visitorConfigSlice.ts'] Result:
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import type { RootState } from './index';

interface VisitorConfigState {
  satisfactionParams: {
    initialValue: number;
    decayRate: number;
    playBoost: number;
    criticalLevel: number;
    maxFailCount: number;
  };
  behaviorParams: {
    updateInterval: number;
    pathfindingRange: number;
    queueingTimeLimit: number;
  };
  visitorParams: {
    totalVisitors: number;
    spawnInterval: number;
    moveSpeed: number;
  };
}

const initialState: VisitorConfigState = {
  satisfactionParams: {
    initialValue: 100,
    decayRate: 0.1,
    playBoost: 10,
    criticalLevel: 50,
    maxFailCount: 3
  },
  behaviorParams: {
    updateInterval: 1000,
    pathfindingRange: 100,
    queueingTimeLimit: 300
  },
  visitorParams: {
    totalVisitors: 20,
    spawnInterval: 5000,
    moveSpeed: 1
  }
};

export const visitorConfigSlice = createSlice({
  name: 'visitorConfig',
  initialState,
  reducers: {
    updateSatisfactionParams: (
      state,
      action: PayloadAction<Partial<VisitorConfigState['satisfactionParams']>>
    ) => {
      state.satisfactionParams = {
        ...state.satisfactionParams,
        ...action.payload
      };
    },
    updateBehaviorParams: (
      state,
      action: PayloadAction<Partial<VisitorConfigState['behaviorParams']>>
    ) => {
      state.behaviorParams = {
        ...state.behaviorParams,
        ...action.payload
      };
    },
    updateVisitorParams: (
      state,
      action: PayloadAction<Partial<VisitorConfigState['visitorParams']>>
    ) => {
      state.visitorParams = {
        ...state.visitorParams,
        ...action.payload
      };
    },
    resetConfig: (state) => {
      state.satisfactionParams = initialState.satisfactionParams;
      state.behaviorParams = initialState.behaviorParams;
      state.visitorParams = initialState.visitorParams;
    }
  }
});

export const {
  updateSatisfactionParams,
  updateBehaviorParams,
  updateVisitorParams,
  resetConfig
} = visitorConfigSlice.actions;

export const selectSatisfactionParams = (state: RootState) =>
  state.visitorConfig.satisfactionParams;
export const selectBehaviorParams = (state: RootState) =>
  state.visitorConfig.behaviorParams;
export const selectVisitorParams = (state: RootState) =>
  state.visitorConfig.visitorParams;

export default visitorConfigSlice.reducer;

<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/visitorConfigSlice.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 2:12:43 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
å¾ visitorConfigSlice çœ‹ä¾†ï¼ŒéŠå®¢ç”Ÿæˆçš„åƒæ•¸æ˜¯å­˜åœ¨çš„ï¼Œä¸”æœ‰ä¸€äº›é è¨­å€¼ï¼štotalVisitors = 20, spawnInterval = 5000ã€‚æ¥ä¸‹ä¾†æˆ‘éœ€è¦æŸ¥çœ‹ visitorSlice ä¾†äº†è§£éŠå®¢çš„ç”Ÿæˆé‚è¼¯ã€‚
</thinking>

<read_file>
<path>src/store/visitorSlice.ts</path>
</read_file>

---

**User:**

[read_file for 'src/store/visitorSlice.ts'] Result:
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Vector2D } from '../utils/PathFinder';
import { VisitorState } from '../components/game/Visitor';

interface VisitorPrediction {
  nextState: VisitorState;
  nextPosition?: Vector2D;
  satisfactionTrend: number;
  timeToNextState: number;
}

interface VisitorInfo {
  id: string;
  position: Vector2D;
  state: VisitorState;
  satisfaction: number;
  lowSatisfactionCount: number;
  prediction?: VisitorPrediction;
}

interface VisitorsState {
  visitors: Record<string, VisitorInfo>;
  selectedVisitorId: string | null;
}

const initialState: VisitorsState = {
  visitors: {},
  selectedVisitorId: null
};

const visitorSlice = createSlice({
  name: 'visitors',
  initialState,
  reducers: {
    updateVisitor(state, action: PayloadAction<VisitorInfo>) {
      const visitor = action.payload;
      state.visitors[visitor.id] = visitor;
    },
    batchUpdateVisitors(state, action: PayloadAction<VisitorInfo[]>) {
      action.payload.forEach(visitor => {
        state.visitors[visitor.id] = visitor;
      });
    },
    removeVisitor(state, action: PayloadAction<string>) {
      delete state.visitors[action.payload];
      if (state.selectedVisitorId === action.payload) {
        state.selectedVisitorId = null;
      }
    },
    selectVisitor(state, action: PayloadAction<string | null>) {
      state.selectedVisitorId = action.payload;
    },
    clearSelectedVisitor(state) {
      state.selectedVisitorId = null;
    }
  }
});

export const {
  updateVisitor,
  batchUpdateVisitors,
  removeVisitor,
  selectVisitor,
  clearSelectedVisitor
} = visitorSlice.actions;

export default visitorSlice.reducer;

<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/visitorConfigSlice.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 2:12:51 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æˆ‘ç™¼ç¾ visitorSlice ä¸­åªæœ‰ç®¡ç†éŠå®¢ç‹€æ…‹çš„é‚è¼¯ï¼Œä½†æ²’æœ‰çœ‹åˆ°å¯¦éš›ç”ŸæˆéŠå®¢çš„ç¨‹å¼ç¢¼ã€‚ç”ŸæˆéŠå®¢çš„é‚è¼¯æ‡‰è©²æ˜¯åœ¨ GameCanvas çµ„ä»¶ä¸­ã€‚è®“æˆ‘æª¢æŸ¥ä¸€ä¸‹ GameCanvas.tsxã€‚
</thinking>

<read_file>
<path>src/components/game/GameCanvas.tsx</path>
</read_file>

---

**User:**

[read_file for 'src/components/game/GameCanvas.tsx'] Result:
import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);
  
  // ä½¿ç”¨ useMemo è¨˜æ†¶åŒ–è¨­æ–½é™£åˆ—
  const facilities = useMemo(() => Object.values(facilitiesMap), [facilitiesMap]);

  // å»ºç«‹éŠå®¢ç”Ÿæˆå‡½æ•¸
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // ä½¿ç”¨è¨˜æ†¶åŒ–çš„ facilities é™£åˆ—æª¢æŸ¥è¨­æ–½è®Šæ›´ä¸¦æ›´æ–° PathFinder
    const obstacles = facilities.map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // åœ¨åœ°åœ–é‚Šç·£éš¨æ©Ÿç”ŸæˆéŠå®¢
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    // å…ˆå°‡éŠå®¢å¯¦ä¾‹åŠ å…¥è¨˜æ†¶é«”ç®¡ç†
    visitorInstancesRef.current.set(newVisitor.id, newVisitor);

    // åªåŠ å…¥è¨˜æ†¶é«”ç®¡ç†ï¼Œè®“éŠæˆ²å¾ªç’°è™•ç†æ›´æ–°
    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilities]);

  // è¨­ç½®éŠå®¢ç”Ÿæˆå®šæ™‚å™¨
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  // å°‡ visitors ç§»åˆ° useEffect å¤–éƒ¨ä¸¦ä½¿ç”¨ useMemo å„ªåŒ–
  const visitors = useMemo(() => Object.values(visitorsMap), [visitorsMap]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    // è¨­ç½® Canvas çš„å¯¦éš›å¤§å°
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    
    // è¨­ç½® CSS å¤§å°
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    
    // èª¿æ•´æ¯”ä¾‹
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let animationFrameId: number;

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // è½‰æ›ç‚ºç§’
      lastTime = currentTime;

      // æ¸…é™¤ç•«å¸ƒ
      context.clearRect(0, 0, width, height);

      // ç¹ªè£½ç¶²æ ¼
      drawGrid(context, width, height);
      
      // ç¹ªè£½è¨­æ–½
      facilities.forEach(facility => {
        drawFacility(context, facility);
      });

      // æ›´æ–°ä¸¦ç¹ªè£½æ¯å€‹éŠå®¢
      visitors.forEach((visitor: VisitorInfo) => {
        // ç²å–æˆ–å‰µå»º Visitor å¯¦ä¾‹
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        // æ›´æ–°ç§»å‹•é€Ÿåº¦
        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦è¨­å®šæ–°ç›®æ¨™
        if (visitorInstance.state === VisitorState.IDLE) {
          if (facilities.length > 0) {
            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹è¨­æ–½ä½œç‚ºç›®æ¨™
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        
        // é™åˆ¶æ›´æ–°é »ç‡ï¼Œç´„æ¯ç§’æ›´æ–°ä¸€æ¬¡ç‹€æ…‹
        if (needsUpdate && currentTime % 1000 < 16.7) {
          dispatch(updateVisitor({
            id: visitorInstance.id,
            position: visitorInstance.position,
            state: visitorInstance.state,
            satisfaction: visitorInstance.satisfaction,
            prediction: visitorInstance.prediction,
            lowSatisfactionCount: visitorInstance.lowSatisfactionCount
          }));
        }

        // ç«‹å³ç¹ªè£½éŠå®¢
        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      // å®šæœŸæ¸…ç†éŠå®¢å¯¦ä¾‹ï¼Œè€Œä¸æ˜¯æ¯å¹€éƒ½æ¸…ç†
      if (currentTime % 1000 < 16.7) { // ç´„æ¯ç§’åŸ·è¡Œä¸€æ¬¡
        const currentIds = new Set(visitors.map((v: VisitorInfo) => v.id));
        for (const [id] of visitorInstancesRef.current) {
          if (!currentIds.has(id)) {
            visitorInstancesRef.current.delete(id);
          }
        }
      }

      // è«‹æ±‚ä¸‹ä¸€å¹€
      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilities, visitors, width, height, visitorParams]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    // ç¹ªè£½å‚ç›´ç·š
    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // ç¹ªè£½æ°´å¹³ç·š
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38; // ç•¥å°æ–¼ç¶²æ ¼å¤§å°
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    // æ ¹æ“šè¨­æ–½ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#4CAF50';  // é è¨­ï¼šç‡Ÿé‹ä¸­
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';  // ç¶­è­·ä¸­
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';  // é—œé–‰ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½è¨­æ–½å¤–æ¡†
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    // ç¹ªè£½è¨­æ–½åç¨±
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    // ç¹ªè£½ç­‰å€™äººæ•¸
    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`ç­‰å€™: ${queueLength}äºº`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    // ä¸å†å°‡ä½ç½®å››æ¨äº”å…¥ï¼Œä½¿å‹•ç•«æ›´å¹³æ»‘
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    // å¦‚æœéŠå®¢æ­£åœ¨ç§»å‹•ï¼Œæ·»åŠ å‹•ç•«æ•ˆæœ
    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      // ç¹ªè£½ç§»å‹•è»Œè·¡
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      // æ·»åŠ ç§»å‹•æ–¹å‘æŒ‡ç¤ºå™¨
      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    // æ ¹æ“šéŠå®¢ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#2196F3';   // é è¨­ï¼šéŠè¦½ä¸­
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';   // æ’éšŠä¸­
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';   // éŠç©ä¸­
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';   // é›¢é–‹ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½éŠå®¢åœ–ç¤º
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // ç¹ªè£½éŠå®¢ç‹€æ…‹
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    // ç¹ªè£½æ»¿æ„åº¦æŒ‡æ¨™
    const satisfactionIcon = visitor.satisfaction >= 80 ? 'ğŸ˜Š' : 
                           visitor.satisfaction >= 50 ? 'ğŸ˜' : 'ğŸ˜';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/visitorConfigSlice.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 2:12:59 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æª¢æŸ¥äº† GameCanvas çµ„ä»¶çš„ä»£ç¢¼ï¼Œæˆ‘ç™¼ç¾éŠå®¢ç”Ÿæˆçš„é‚è¼¯ä¸»è¦åœ¨ spawnVisitor å‡½æ•¸ä¸­ã€‚é€™å€‹å‡½æ•¸åšäº†å¹¾ä»¶äº‹ï¼š

1. æª¢æŸ¥ç•¶å‰éŠå®¢æ•¸é‡æ˜¯å¦å·²é”åˆ°ä¸Šé™ï¼š
```typescript
if (visitorCount >= visitorParams.totalVisitors) return;
```

2. é€é setInterval å®šæ™‚åŸ·è¡Œ spawnVisitorï¼š
```typescript
useEffect(() => {
  const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
  return () => clearInterval(spawnTimer);
}, [spawnVisitor, visitorParams.spawnInterval]);
```

è®“æˆ‘æª¢æŸ¥æ˜¯å¦æœ‰æ­£ç¢ºè¨­ç½® visitorCount çš„é‚è¼¯ã€‚
</thinking>

<read_file>
<path>src/components/game/Visitor.ts</path>
</read_file>

---

**User:**

[read_file for 'src/components/game/Visitor.ts'] Result:
import { PathFinder, Vector2D } from '../../utils/PathFinder';
import { SatisfactionManager } from '../../utils/SatisfactionManager';

/**
 * éŠå®¢ç‹€æ…‹åˆ—èˆ‰
 */
export enum VisitorState {
  IDLE = 'IDLE',           // é–’ç½®ç‹€æ…‹
  MOVING = 'MOVING',       // ç§»å‹•ä¸­
  QUEUING = 'QUEUING',     // æ’éšŠä¸­
  PLAYING = 'PLAYING',     // éŠç©ä¸­
  LEAVING = 'LEAVING'      // æº–å‚™é›¢é–‹
}

/**
 * éŠå®¢ä»‹é¢
 */
export interface IVisitor {
  id: string;             // å”¯ä¸€è­˜åˆ¥ç¢¼
  position: Vector2D;     // ç•¶å‰ä½ç½®
  state: VisitorState;    // ç•¶å‰ç‹€æ…‹
  satisfaction: number;   // ç•¶å‰æ»¿æ„åº¦
  lowSatisfactionCount: number;  // ä½æ»¿æ„åº¦è¨ˆæ•¸å™¨
  prediction?: {
    nextState: VisitorState;      // é æ¸¬çš„ä¸‹ä¸€å€‹ç‹€æ…‹
    nextPosition?: Vector2D;      // é æ¸¬çš„ä¸‹ä¸€å€‹ä½ç½®
    satisfactionTrend: number;    // é æ¸¬çš„æ»¿æ„åº¦è¶¨å‹¢ï¼ˆæ­£æ•¸è¡¨ç¤ºä¸Šå‡ï¼Œè² æ•¸è¡¨ç¤ºä¸‹é™ï¼‰
    timeToNextState: number;      // é æ¸¬åˆ°é”ä¸‹ä¸€å€‹ç‹€æ…‹çš„æ™‚é–“ï¼ˆç§’ï¼‰
  };
}

/**
 * éŠå®¢é¡åˆ¥
 * ç®¡ç†éŠå®¢çš„è¡Œç‚ºã€ç‹€æ…‹å’Œæ»¿æ„åº¦
 */
export class Visitor implements IVisitor {
  public readonly id: string;
  public position: Vector2D;
  public state: VisitorState;
  public prediction?: {
    nextState: VisitorState;
    nextPosition?: Vector2D;
    satisfactionTrend: number;
    timeToNextState: number;
  };
  
  private pathFinder: PathFinder;
  private satisfactionManager: SatisfactionManager;
  private currentPath: Vector2D[];
  public lowSatisfactionCount: number;
  private lastUpdateTime: number;
  private moveSpeed: number;
  private static readonly SATISFACTION_THRESHOLD = 50;
  private static readonly MAX_LOW_SATISFACTION_COUNT = 3;

  constructor(
    id: string,
    initialPosition: Vector2D,
    pathFinder: PathFinder,
    moveSpeed: number = 2
  ) {
    this.lastUpdateTime = Date.now();
    this.id = id;
    this.moveSpeed = moveSpeed;
    // ç¢ºä¿åˆå§‹ä½ç½®ç‚ºæ•´æ•¸
    this.position = {
      x: Math.round(initialPosition.x),
      y: Math.round(initialPosition.y)
    };
    this.state = VisitorState.IDLE;
    this.currentPath = [];
    this.lowSatisfactionCount = 0;

    // ä½¿ç”¨å…±ç”¨çš„è·¯å¾‘å°‹æ‰¾å™¨
    this.pathFinder = pathFinder;
    
    // åˆå§‹åŒ–æ»¿æ„åº¦ç®¡ç†å™¨
    this.satisfactionManager = new SatisfactionManager();
  }

  /**
   * è¨­ç½®ç§»å‹•é€Ÿåº¦
   */
  public setMoveSpeed(speed: number): void {
    this.moveSpeed = speed;
  }

  /**
   * å–å¾—ç•¶å‰æ»¿æ„åº¦
   */
  public get satisfaction(): number {
    return this.satisfactionManager.getSatisfaction();
  }

  /**
   * æ›´æ–°éŠå®¢ä½ç½®
   */
  public moveTo(target: Vector2D): void {
    // é‡ç½®ç‹€æ…‹
    this.state = VisitorState.IDLE;
    this.currentPath = [];

    // ç¢ºä¿ç›®æ¨™ä½ç½®ç‚ºæ•´æ•¸
    const roundedTarget = {
      x: Math.round(target.x),
      y: Math.round(target.y)
    };

    // æª¢æŸ¥ç›®æ¨™é»èˆ‡ç•¶å‰ä½ç½®æ˜¯å¦ç›¸åŒ
    if (roundedTarget.x === this.position.x && roundedTarget.y === this.position.y) {
      this.state = VisitorState.IDLE;
      this.currentPath = [];
      return;
    }

    // è¨ˆç®—è·¯å¾‘
    const path = this.pathFinder.findPath(this.position, roundedTarget);
    
    // æª¢æŸ¥è·¯å¾‘æœ‰æ•ˆæ€§
    if (!path || path.length === 0 || path.length === 1) {
      this.state = VisitorState.IDLE;
      this.currentPath = [];
      return;
    }

    // æª¢æŸ¥è·¯å¾‘æ˜¯å¦çœŸæ­£å¯é”ç›®æ¨™
    const lastPoint = path[path.length - 1];
    if (lastPoint.x !== roundedTarget.x || lastPoint.y !== roundedTarget.y) {
      this.state = VisitorState.IDLE;
      this.currentPath = [];
      return;
    }

    // æª¢æŸ¥ç¬¬ä¸€æ­¥æ˜¯å¦æœ‰æ•ˆ
    const firstStep = path[1];
    if (firstStep.x === this.position.x && firstStep.y === this.position.y) {
      this.state = VisitorState.IDLE;
      this.currentPath = [];
      return;
    }

    // è¨­å®šç§»å‹•è·¯å¾‘ï¼ˆæ’é™¤èµ·é»ï¼‰
    this.currentPath = path.slice(1);
    this.state = VisitorState.MOVING;
  }

  /**
   * æ›´æ–°éŠå®¢ç‹€æ…‹
   * @param deltaTime æ™‚é–“å·®ï¼ˆç§’ï¼‰
   * @returns è¿”å›æ˜¯å¦éœ€è¦é›¢é–‹éŠæ¨‚åœ’
   */
  public update(deltaTime: number): boolean {
    this.updatePrediction();
    // è™•ç†ç§»å‹•ç‹€æ…‹
    if (this.state === VisitorState.MOVING && this.currentPath.length > 0) {
      const nextPosition = this.currentPath[0];
      const distance = Math.sqrt(
        Math.pow(nextPosition.x - this.position.x, 2) +
        Math.pow(nextPosition.y - this.position.y, 2)
      );

      // åˆ°é”æª¢æŸ¥å’Œç§»å‹•é‚è¼¯
      const step = Math.min(this.moveSpeed * deltaTime, distance);

      if (step >= distance) {
        // ç›´æ¥åˆ°é”ç›®æ¨™é»
        this.position = { ...nextPosition };
        this.currentPath.shift(); // ç§»é™¤å·²åˆ°é”çš„é»
        
        // å¦‚æœè·¯å¾‘æ¸…ç©ºï¼Œè½‰ç‚ºé–’ç½®ç‹€æ…‹
        if (this.currentPath.length === 0) {
          this.state = VisitorState.IDLE;
        }
      } else {
        // è¨ˆç®—ä¸¦æ›´æ–°æ–°ä½ç½®
        const ratio = step / distance;
        this.position = {
          x: this.position.x + (nextPosition.x - this.position.x) * ratio,
          y: this.position.y + (nextPosition.y - this.position.y) * ratio
        };
      }
    }

    // æª¢æŸ¥æ»¿æ„åº¦ç‹€æ…‹
    if (this.state !== VisitorState.LEAVING) {
      if (this.satisfactionManager.isBelowThreshold(Visitor.SATISFACTION_THRESHOLD)) {
        this.lowSatisfactionCount++;
        
        if (this.lowSatisfactionCount >= Visitor.MAX_LOW_SATISFACTION_COUNT) {
          this.state = VisitorState.LEAVING;
          return true;
        }
      } else {
        this.lowSatisfactionCount = 0;
      }
    }

    return this.state === VisitorState.LEAVING;
  }

  /**
   * é–‹å§‹æ’éšŠ
   */
  public startQueuing(waitingTime: number): void {
    this.state = VisitorState.QUEUING;
    if (waitingTime > 0) {
      const satisfactionDrop = -(waitingTime / 60) * 15;
      this.satisfactionManager.updateSatisfaction(satisfactionDrop);
      
      if (this.satisfaction < Visitor.SATISFACTION_THRESHOLD) {
        this.lowSatisfactionCount++;
      }
    }
  }

  /**
   * é–‹å§‹éŠç©è¨­æ–½
   */
  public startPlaying(): void {
    this.state = VisitorState.PLAYING;
  }

  /**
   * å®ŒæˆéŠç©è¨­æ–½
   */
  public finishPlaying(): void {
    this.satisfactionManager.boostAfterPlay();
    this.state = VisitorState.IDLE;
    
    if (this.satisfaction >= Visitor.SATISFACTION_THRESHOLD) {
      this.lowSatisfactionCount = 0;
    }
  }

  /**
   * æª¢æŸ¥æ˜¯å¦éœ€è¦å°‹æ‰¾æ–°çš„è¨­æ–½
   */
  public needsNewAttraction(): boolean {
    return this.satisfaction < Visitor.SATISFACTION_THRESHOLD;
  }

  /**
   * æ›´æ–°é æ¸¬è³‡è¨Š
   */
  private updatePrediction(): void {
    const currentTime = Date.now();
    const timeSinceLastUpdate = (currentTime - this.lastUpdateTime) / 1000;
    
    let nextState = this.state;
    let nextPosition = undefined;
    let satisfactionTrend = 0;
    let timeToNextState = 0;

    switch (this.state) {
      case VisitorState.IDLE:
        nextState = VisitorState.MOVING;
        timeToNextState = 1;
        satisfactionTrend = this.needsNewAttraction() ? -5 : -2;
        break;

      case VisitorState.MOVING:
        if (this.currentPath.length > 0) {
          nextPosition = this.currentPath[0];
          const distance = Math.sqrt(
            Math.pow(nextPosition.x - this.position.x, 2) +
            Math.pow(nextPosition.y - this.position.y, 2)
          );
          nextState = VisitorState.IDLE;
          timeToNextState = distance / this.moveSpeed;
          satisfactionTrend = -2;
        } else {
          nextState = VisitorState.IDLE;
          timeToNextState = 0.5;
          satisfactionTrend = -1;
        }
        break;

      case VisitorState.QUEUING:
        nextState = VisitorState.PLAYING;
        timeToNextState = 5;
        satisfactionTrend = -15;
        break;

      case VisitorState.PLAYING:
        nextState = VisitorState.IDLE;
        timeToNextState = 3;
        satisfactionTrend = 10;
        break;

      case VisitorState.LEAVING:
        satisfactionTrend = -10;
        break;
    }

    this.prediction = {
      nextState,
      nextPosition,
      satisfactionTrend,
      timeToNextState: Math.max(0, timeToNextState - timeSinceLastUpdate)
    };

    this.lastUpdateTime = currentTime;
  }

  /**
   * ç”¨æ–¼æ¸¬è©¦çš„è¼”åŠ©æ–¹æ³•ï¼šç›´æ¥è¨­ç½®æ»¿æ„åº¦
   */
  public _testSetSatisfaction(value: number): void {
    this.satisfactionManager.updateSatisfaction(value - this.satisfaction);
  }
}

<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/visitorConfigSlice.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 2:13:09 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æª¢æŸ¥å®Œç›¸é—œä»£ç¢¼å¾Œï¼Œæˆ‘ç™¼ç¾å¯èƒ½çš„å•é¡Œï¼š

1. åœ¨ GameCanvas ä¸­æˆ‘å€‘çœ‹åˆ° visitorCount æ˜¯ç”¨ useState ç¶­è­·çš„ï¼š
```typescript
const [visitorCount, setVisitorCount] = useState(0);
```

ä½†æ˜¯ï¼ŒvisitorCount åªåœ¨ spawnVisitor å‡½æ•¸ä¸­è¢«å¢åŠ ï¼Œæ²’æœ‰åœ¨éŠå®¢é›¢é–‹æ™‚æ¸›å°‘ã€‚é€™å¯èƒ½å°è‡´è¨ˆæ•¸å™¨ä¸æº–ç¢ºï¼Œé€²è€Œå½±éŸ¿æ–°éŠå®¢çš„ç”Ÿæˆã€‚

æˆ‘å€‘éœ€è¦åœ¨éŠå®¢é›¢é–‹æ™‚æ›´æ–° visitorCountã€‚æ‰¾æ‰¾ GameCanvas ä¸­çš„æ¸…ç†éŠå®¢é‚è¼¯ã€‚åœ¨ GameCanvas ä¸­æœ‰ä¸€æ®µæ¸…ç†ä»£ç¢¼ï¼š

```typescript
if (currentTime % 1000 < 16.7) {
  const currentIds = new Set(visitors.map((v: VisitorInfo) => v.id));
  for (const [id] of visitorInstancesRef.current) {
    if (!currentIds.has(id)) {
      visitorInstancesRef.current.delete(id);
    }
  }
}
```

é€™æ®µä»£ç¢¼åªæ¸…ç†äº†éŠå®¢å¯¦ä¾‹ï¼Œä½†æ²’æœ‰æ›´æ–° visitorCountã€‚è®“æˆ‘ä¿®æ”¹é€™å€‹å•é¡Œã€‚
</thinking>

<replace_in_file>
<path>src/components/game/GameCanvas.tsx</path>
<diff>
<<<<<<< SEARCH
  if (currentTime % 1000 < 16.7) { // ç´„æ¯ç§’åŸ·è¡Œä¸€æ¬¡
    const currentIds = new Set(visitors.map((v: VisitorInfo) => v.id));
    for (const [id] of visitorInstancesRef.current) {
      if (!currentIds.has(id)) {
        visitorInstancesRef.current.delete(id);
      }
    }
  }
=======
  if (currentTime % 1000 < 16.7) { // ç´„æ¯ç§’åŸ·è¡Œä¸€æ¬¡
    const currentIds = new Set(visitors.map((v: VisitorInfo) => v.id));
    let deletedCount = 0;
    for (const [id] of visitorInstancesRef.current) {
      if (!currentIds.has(id)) {
        visitorInstancesRef.current.delete(id);
        deletedCount++;
      }
    }
    if (deletedCount > 0) {
      // æ›´æ–°éŠå®¢è¨ˆæ•¸
      setVisitorCount(prev => Math.max(0, prev - deletedCount));
    }
  }
>>>>>>> REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/components/game/GameCanvas.tsx'] Result:
The content was successfully saved to src/components/game/GameCanvas.tsx.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/components/game/GameCanvas.tsx">
import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);
  
  // ä½¿ç”¨ useMemo è¨˜æ†¶åŒ–è¨­æ–½é™£åˆ—
  const facilities = useMemo(() => Object.values(facilitiesMap), [facilitiesMap]);

  // å»ºç«‹éŠå®¢ç”Ÿæˆå‡½æ•¸
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // ä½¿ç”¨è¨˜æ†¶åŒ–çš„ facilities é™£åˆ—æª¢æŸ¥è¨­æ–½è®Šæ›´ä¸¦æ›´æ–° PathFinder
    const obstacles = facilities.map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // åœ¨åœ°åœ–é‚Šç·£éš¨æ©Ÿç”ŸæˆéŠå®¢
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    // å…ˆå°‡éŠå®¢å¯¦ä¾‹åŠ å…¥è¨˜æ†¶é«”ç®¡ç†
    visitorInstancesRef.current.set(newVisitor.id, newVisitor);

    // åªåŠ å…¥è¨˜æ†¶é«”ç®¡ç†ï¼Œè®“éŠæˆ²å¾ªç’°è™•ç†æ›´æ–°
    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilities]);

  // è¨­ç½®éŠå®¢ç”Ÿæˆå®šæ™‚å™¨
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  // å°‡ visitors ç§»åˆ° useEffect å¤–éƒ¨ä¸¦ä½¿ç”¨ useMemo å„ªåŒ–
  const visitors = useMemo(() => Object.values(visitorsMap), [visitorsMap]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    // è¨­ç½® Canvas çš„å¯¦éš›å¤§å°
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    
    // è¨­ç½® CSS å¤§å°
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    
    // èª¿æ•´æ¯”ä¾‹
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let animationFrameId: number;

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // è½‰æ›ç‚ºç§’
      lastTime = currentTime;

      // æ¸…é™¤ç•«å¸ƒ
      context.clearRect(0, 0, width, height);

      // ç¹ªè£½ç¶²æ ¼
      drawGrid(context, width, height);
      
      // ç¹ªè£½è¨­æ–½
      facilities.forEach(facility => {
        drawFacility(context, facility);
      });

      // æ›´æ–°ä¸¦ç¹ªè£½æ¯å€‹éŠå®¢
      visitors.forEach((visitor: VisitorInfo) => {
        // ç²å–æˆ–å‰µå»º Visitor å¯¦ä¾‹
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        // æ›´æ–°ç§»å‹•é€Ÿåº¦
        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦è¨­å®šæ–°ç›®æ¨™
        if (visitorInstance.state === VisitorState.IDLE) {
          if (facilities.length > 0) {
            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹è¨­æ–½ä½œç‚ºç›®æ¨™
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        
        // é™åˆ¶æ›´æ–°é »ç‡ï¼Œç´„æ¯ç§’æ›´æ–°ä¸€æ¬¡ç‹€æ…‹
        if (needsUpdate && currentTime % 1000 < 16.7) {
          dispatch(updateVisitor({
            id: visitorInstance.id,
            position: visitorInstance.position,
            state: visitorInstance.state,
            satisfaction: visitorInstance.satisfaction,
            prediction: visitorInstance.prediction,
            lowSatisfactionCount: visitorInstance.lowSatisfactionCount
          }));
        }

        // ç«‹å³ç¹ªè£½éŠå®¢
        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      // å®šæœŸæ¸…ç†éŠå®¢å¯¦ä¾‹ï¼Œè€Œä¸æ˜¯æ¯å¹€éƒ½æ¸…ç†
  if (currentTime % 1000 < 16.7) { // ç´„æ¯ç§’åŸ·è¡Œä¸€æ¬¡
    const currentIds = new Set(visitors.map((v: VisitorInfo) => v.id));
    let deletedCount = 0;
    for (const [id] of visitorInstancesRef.current) {
      if (!currentIds.has(id)) {
        visitorInstancesRef.current.delete(id);
        deletedCount++;
      }
    }
    if (deletedCount > 0) {
      // æ›´æ–°éŠå®¢è¨ˆæ•¸
      setVisitorCount(prev => Math.max(0, prev - deletedCount));
    }
  }

      // è«‹æ±‚ä¸‹ä¸€å¹€
      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilities, visitors, width, height, visitorParams]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    // ç¹ªè£½å‚ç›´ç·š
    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // ç¹ªè£½æ°´å¹³ç·š
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38; // ç•¥å°æ–¼ç¶²æ ¼å¤§å°
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    // æ ¹æ“šè¨­æ–½ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#4CAF50';  // é è¨­ï¼šç‡Ÿé‹ä¸­
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';  // ç¶­è­·ä¸­
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';  // é—œé–‰ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½è¨­æ–½å¤–æ¡†
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    // ç¹ªè£½è¨­æ–½åç¨±
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    // ç¹ªè£½ç­‰å€™äººæ•¸
    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`ç­‰å€™: ${queueLength}äºº`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    // ä¸å†å°‡ä½ç½®å››æ¨äº”å…¥ï¼Œä½¿å‹•ç•«æ›´å¹³æ»‘
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    // å¦‚æœéŠå®¢æ­£åœ¨ç§»å‹•ï¼Œæ·»åŠ å‹•ç•«æ•ˆæœ
    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      // ç¹ªè£½ç§»å‹•è»Œè·¡
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      // æ·»åŠ ç§»å‹•æ–¹å‘æŒ‡ç¤ºå™¨
      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    // æ ¹æ“šéŠå®¢ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#2196F3';   // é è¨­ï¼šéŠè¦½ä¸­
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';   // æ’éšŠä¸­
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';   // éŠç©ä¸­
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';   // é›¢é–‹ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½éŠå®¢åœ–ç¤º
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // ç¹ªè£½éŠå®¢ç‹€æ…‹
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    // ç¹ªè£½æ»¿æ„åº¦æŒ‡æ¨™
    const satisfactionIcon = visitor.satisfaction >= 80 ? 'ğŸ˜Š' : 
                           visitor.satisfaction >= 50 ? 'ğŸ˜' : 'ğŸ˜';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/visitorConfigSlice.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 2:13:46 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æˆ‘å·²ç¶“ä¿®æ”¹äº†éŠå®¢æ¸…ç†çš„é‚è¼¯ï¼Œç¾åœ¨æœƒåœ¨æ¸…ç†éŠå®¢æ™‚åŒæ™‚æ›´æ–° visitorCountã€‚è®“æˆ‘å€‘å†çœ‹çœ‹ spawnVisitor å‡½æ•¸ä¸­æ–°éŠå®¢çš„ç”Ÿæˆé‚è¼¯ï¼Œæ˜¯å¦å¯ä»¥å†åšä¸€äº›æ”¹é€²ä¾†ç¢ºä¿éŠå®¢èƒ½æ­£ç¢ºç”Ÿæˆã€‚
</thinking>

<replace_in_file>
<path>src/components/game/GameCanvas.tsx</path>
<diff>
<<<<<<< SEARCH
  // å»ºç«‹éŠå®¢ç”Ÿæˆå‡½æ•¸
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // ä½¿ç”¨è¨˜æ†¶åŒ–çš„ facilities é™£åˆ—æª¢æŸ¥è¨­æ–½è®Šæ›´ä¸¦æ›´æ–° PathFinder
    const obstacles = facilities.map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // åœ¨åœ°åœ–é‚Šç·£éš¨æ©Ÿç”ŸæˆéŠå®¢
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    // å…ˆå°‡éŠå®¢å¯¦ä¾‹åŠ å…¥è¨˜æ†¶é«”ç®¡ç†
    visitorInstancesRef.current.set(newVisitor.id, newVisitor);

    // åªåŠ å…¥è¨˜æ†¶é«”ç®¡ç†ï¼Œè®“éŠæˆ²å¾ªç’°è™•ç†æ›´æ–°
    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilities]);
=======
  // å»ºç«‹éŠå®¢ç”Ÿæˆå‡½æ•¸
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // ä½¿ç”¨è¨˜æ†¶åŒ–çš„ facilities é™£åˆ—æª¢æŸ¥è¨­æ–½è®Šæ›´ä¸¦æ›´æ–° PathFinder
    const obstacles = facilities.map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // åœ¨åœ°åœ–é‚Šç·£éš¨æ©Ÿç”ŸæˆéŠå®¢
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    // å…ˆå°‡éŠå®¢å¯¦ä¾‹åŠ å…¥è¨˜æ†¶é«”ç®¡ç†
    visitorInstancesRef.current.set(newVisitor.id, newVisitor);

    // æ›´æ–° Redux store
    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      prediction: newVisitor.prediction,
      lowSatisfactionCount: newVisitor.lowSatisfactionCount
    }));

    // æ›´æ–°éŠå®¢è¨ˆæ•¸
    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilities]);
>>>>>>> REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/components/game/GameCanvas.tsx'] Result:
The content was successfully saved to src/components/game/GameCanvas.tsx.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/components/game/GameCanvas.tsx">
import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);
  
  // ä½¿ç”¨ useMemo è¨˜æ†¶åŒ–è¨­æ–½é™£åˆ—
  const facilities = useMemo(() => Object.values(facilitiesMap), [facilitiesMap]);

  // å»ºç«‹éŠå®¢ç”Ÿæˆå‡½æ•¸
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // ä½¿ç”¨è¨˜æ†¶åŒ–çš„ facilities é™£åˆ—æª¢æŸ¥è¨­æ–½è®Šæ›´ä¸¦æ›´æ–° PathFinder
    const obstacles = facilities.map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // åœ¨åœ°åœ–é‚Šç·£éš¨æ©Ÿç”ŸæˆéŠå®¢
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    // å…ˆå°‡éŠå®¢å¯¦ä¾‹åŠ å…¥è¨˜æ†¶é«”ç®¡ç†
    visitorInstancesRef.current.set(newVisitor.id, newVisitor);

    // æ›´æ–° Redux store
    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      prediction: newVisitor.prediction,
      lowSatisfactionCount: newVisitor.lowSatisfactionCount
    }));

    // æ›´æ–°éŠå®¢è¨ˆæ•¸
    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilities]);

  // è¨­ç½®éŠå®¢ç”Ÿæˆå®šæ™‚å™¨
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  // å°‡ visitors ç§»åˆ° useEffect å¤–éƒ¨ä¸¦ä½¿ç”¨ useMemo å„ªåŒ–
  const visitors = useMemo(() => Object.values(visitorsMap), [visitorsMap]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    // è¨­ç½® Canvas çš„å¯¦éš›å¤§å°
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    
    // è¨­ç½® CSS å¤§å°
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    
    // èª¿æ•´æ¯”ä¾‹
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let animationFrameId: number;

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // è½‰æ›ç‚ºç§’
      lastTime = currentTime;

      // æ¸…é™¤ç•«å¸ƒ
      context.clearRect(0, 0, width, height);

      // ç¹ªè£½ç¶²æ ¼
      drawGrid(context, width, height);
      
      // ç¹ªè£½è¨­æ–½
      facilities.forEach(facility => {
        drawFacility(context, facility);
      });

      // æ›´æ–°ä¸¦ç¹ªè£½æ¯å€‹éŠå®¢
      visitors.forEach((visitor: VisitorInfo) => {
        // ç²å–æˆ–å‰µå»º Visitor å¯¦ä¾‹
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        // æ›´æ–°ç§»å‹•é€Ÿåº¦
        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦è¨­å®šæ–°ç›®æ¨™
        if (visitorInstance.state === VisitorState.IDLE) {
          if (facilities.length > 0) {
            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹è¨­æ–½ä½œç‚ºç›®æ¨™
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        
        // é™åˆ¶æ›´æ–°é »ç‡ï¼Œç´„æ¯ç§’æ›´æ–°ä¸€æ¬¡ç‹€æ…‹
        if (needsUpdate && currentTime % 1000 < 16.7) {
          dispatch(updateVisitor({
            id: visitorInstance.id,
            position: visitorInstance.position,
            state: visitorInstance.state,
            satisfaction: visitorInstance.satisfaction,
            prediction: visitorInstance.prediction,
            lowSatisfactionCount: visitorInstance.lowSatisfactionCount
          }));
        }

        // ç«‹å³ç¹ªè£½éŠå®¢
        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      // å®šæœŸæ¸…ç†éŠå®¢å¯¦ä¾‹ï¼Œè€Œä¸æ˜¯æ¯å¹€éƒ½æ¸…ç†
  if (currentTime % 1000 < 16.7) { // ç´„æ¯ç§’åŸ·è¡Œä¸€æ¬¡
    const currentIds = new Set(visitors.map((v: VisitorInfo) => v.id));
    let deletedCount = 0;
    for (const [id] of visitorInstancesRef.current) {
      if (!currentIds.has(id)) {
        visitorInstancesRef.current.delete(id);
        deletedCount++;
      }
    }
    if (deletedCount > 0) {
      // æ›´æ–°éŠå®¢è¨ˆæ•¸
      setVisitorCount(prev => Math.max(0, prev - deletedCount));
    }
  }

      // è«‹æ±‚ä¸‹ä¸€å¹€
      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilities, visitors, width, height, visitorParams]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    // ç¹ªè£½å‚ç›´ç·š
    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // ç¹ªè£½æ°´å¹³ç·š
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38; // ç•¥å°æ–¼ç¶²æ ¼å¤§å°
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    // æ ¹æ“šè¨­æ–½ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#4CAF50';  // é è¨­ï¼šç‡Ÿé‹ä¸­
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';  // ç¶­è­·ä¸­
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';  // é—œé–‰ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½è¨­æ–½å¤–æ¡†
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    // ç¹ªè£½è¨­æ–½åç¨±
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    // ç¹ªè£½ç­‰å€™äººæ•¸
    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`ç­‰å€™: ${queueLength}äºº`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    // ä¸å†å°‡ä½ç½®å››æ¨äº”å…¥ï¼Œä½¿å‹•ç•«æ›´å¹³æ»‘
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    // å¦‚æœéŠå®¢æ­£åœ¨ç§»å‹•ï¼Œæ·»åŠ å‹•ç•«æ•ˆæœ
    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      // ç¹ªè£½ç§»å‹•è»Œè·¡
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      // æ·»åŠ ç§»å‹•æ–¹å‘æŒ‡ç¤ºå™¨
      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    // æ ¹æ“šéŠå®¢ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#2196F3';   // é è¨­ï¼šéŠè¦½ä¸­
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';   // æ’éšŠä¸­
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';   // éŠç©ä¸­
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';   // é›¢é–‹ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½éŠå®¢åœ–ç¤º
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // ç¹ªè£½éŠå®¢ç‹€æ…‹
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    // ç¹ªè£½æ»¿æ„åº¦æŒ‡æ¨™
    const satisfactionIcon = visitor.satisfaction >= 80 ? 'ğŸ˜Š' : 
                           visitor.satisfaction >= 50 ? 'ğŸ˜' : 'ğŸ˜';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/visitorConfigSlice.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 2:14:48 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æˆ‘å·²ç¶“ä¿®æ”¹äº†ä»¥ä¸‹å…©å€‹ä¸»è¦å•é¡Œï¼š

1. åœ¨æ¸…ç†éŠå®¢æ™‚å¢åŠ äº†è¨ˆæ•¸å™¨çš„æ›´æ–°ï¼Œé€™æ¨£ç•¶éŠå®¢é›¢é–‹æ™‚ visitorCount æœƒæ­£ç¢ºæ¸›å°‘ã€‚

2. åœ¨ spawnVisitor å‡½æ•¸ä¸­ï¼Œç¾åœ¨æœƒç«‹å³æ›´æ–° Redux storeï¼š
```typescript
dispatch(updateVisitor({
  id: newVisitor.id,
  position: newVisitor.position,
  state: newVisitor.state,
  satisfaction: newVisitor.satisfaction,
  prediction: newVisitor.prediction,
  lowSatisfactionCount: newVisitor.lowSatisfactionCount
}));
```

é€™æ¨£æ–°éŠå®¢æœƒç«‹å³è¢«åŠ å…¥åˆ° Redux store ä¸­ï¼Œè€Œä¸ç”¨ç­‰åˆ°ä¸‹ä¸€å€‹éŠæˆ²å¾ªç’°æ‰æ›´æ–°ã€‚

è®“æˆ‘ç”¨ attempt_completion ä¾†ç¸½çµä¿®æ”¹ï¼š
</thinking>

<attempt_completion>
<result>
æˆ‘å·²ç¶“ä¿®å¾©äº†éŠå®¢ç„¡æ³•ç”Ÿæˆçš„å•é¡Œï¼Œä¸»è¦ä¿®æ”¹äº†å…©å€‹éƒ¨åˆ†ï¼š

1. ä¿®æ­£äº†éŠå®¢è¨ˆæ•¸é‚è¼¯ï¼Œç¾åœ¨æœƒåœ¨éŠå®¢é›¢é–‹æ™‚æ­£ç¢ºæ¸›å°‘è¨ˆæ•¸å™¨ã€‚
2. åœ¨ç”Ÿæˆæ–°éŠå®¢æ™‚ç«‹å³æ›´æ–° Redux storeï¼Œç¢ºä¿éŠå®¢èƒ½ç«‹å³é¡¯ç¤ºåœ¨ç•«é¢ä¸Šã€‚

é€™äº›ä¿®æ”¹æ‡‰è©²èƒ½ç¢ºä¿éŠå®¢èƒ½å¤ æ­£å¸¸ç”Ÿæˆä¸¦é¡¯ç¤ºåœ¨éŠæ¨‚åœ’ä¸­ã€‚ç³»çµ±æœƒä¾ç…§è¨­å®šçš„é–“éš”ï¼ˆvisitorParams.spawnIntervalï¼‰æŒçºŒç”Ÿæˆæ–°éŠå®¢ï¼Œç›´åˆ°é”åˆ°è¨­å®šçš„æœ€å¤§éŠå®¢æ•¸é‡ï¼ˆvisitorParams.totalVisitorsï¼‰ã€‚
</result>
</attempt_completion>

---

**User:**

[attempt_completion] Result:
The user has provided feedback on the results. Consider their input to continue the task, and then attempt completion again.
<feedback>
ä¿®æ”¹éŠå®¢åˆå§‹åŒ–æ•¸é‡ï¼Œç”± 20 æ”¹ç‚º 10
</feedback>
<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/visitorConfigSlice.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 2:15:55 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æˆ‘éœ€è¦ä¿®æ”¹ visitorConfigSlice.ts ä¸­çš„åˆå§‹éŠå®¢æ•¸é‡è¨­å®šï¼Œå¾ 20 æ”¹ç‚º 10ã€‚
</thinking>

<replace_in_file>
<path>src/store/visitorConfigSlice.ts</path>
<diff>
<<<<<<< SEARCH
  visitorParams: {
    totalVisitors: 20,
    spawnInterval: 5000,
    moveSpeed: 1
  }
=======
  visitorParams: {
    totalVisitors: 10,
    spawnInterval: 5000,
    moveSpeed: 1
  }
>>>>>>> REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/store/visitorConfigSlice.ts'] Result:
The content was successfully saved to src/store/visitorConfigSlice.ts.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/store/visitorConfigSlice.ts">
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import type { RootState } from './index';

interface VisitorConfigState {
  satisfactionParams: {
    initialValue: number;
    decayRate: number;
    playBoost: number;
    criticalLevel: number;
    maxFailCount: number;
  };
  behaviorParams: {
    updateInterval: number;
    pathfindingRange: number;
    queueingTimeLimit: number;
  };
  visitorParams: {
    totalVisitors: number;
    spawnInterval: number;
    moveSpeed: number;
  };
}

const initialState: VisitorConfigState = {
  satisfactionParams: {
    initialValue: 100,
    decayRate: 0.1,
    playBoost: 10,
    criticalLevel: 50,
    maxFailCount: 3
  },
  behaviorParams: {
    updateInterval: 1000,
    pathfindingRange: 100,
    queueingTimeLimit: 300
  },
  visitorParams: {
    totalVisitors: 10,
    spawnInterval: 5000,
    moveSpeed: 1
  }
};

export const visitorConfigSlice = createSlice({
  name: 'visitorConfig',
  initialState,
  reducers: {
    updateSatisfactionParams: (
      state,
      action: PayloadAction<Partial<VisitorConfigState['satisfactionParams']>>
    ) => {
      state.satisfactionParams = {
        ...state.satisfactionParams,
        ...action.payload
      };
    },
    updateBehaviorParams: (
      state,
      action: PayloadAction<Partial<VisitorConfigState['behaviorParams']>>
    ) => {
      state.behaviorParams = {
        ...state.behaviorParams,
        ...action.payload
      };
    },
    updateVisitorParams: (
      state,
      action: PayloadAction<Partial<VisitorConfigState['visitorParams']>>
    ) => {
      state.visitorParams = {
        ...state.visitorParams,
        ...action.payload
      };
    },
    resetConfig: (state) => {
      state.satisfactionParams = initialState.satisfactionParams;
      state.behaviorParams = initialState.behaviorParams;
      state.visitorParams = initialState.visitorParams;
    }
  }
});

export const {
  updateSatisfactionParams,
  updateBehaviorParams,
  updateVisitorParams,
  resetConfig
} = visitorConfigSlice.actions;

export const selectSatisfactionParams = (state: RootState) =>
  state.visitorConfig.satisfactionParams;
export const selectBehaviorParams = (state: RootState) =>
  state.visitorConfig.behaviorParams;
export const selectVisitorParams = (state: RootState) =>
  state.visitorConfig.visitorParams;

export default visitorConfigSlice.reducer;

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/store/visitorConfigSlice.ts

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx
src/store/visitorConfigSlice.ts

# Current Time
3/31/2025, 2:16:24 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æˆ‘å·²ç¶“å°‡éŠå®¢åˆå§‹åŒ–æ•¸é‡å¾ 20 æ”¹ç‚º 10ã€‚é€™å€‹ä¿®æ”¹æœƒå½±éŸ¿éŠæ¨‚åœ’ä¸­åŒæ™‚å­˜åœ¨çš„æœ€å¤§éŠå®¢æ•¸é‡ã€‚ç¾åœ¨å¯ä»¥å®Œæˆé€™é …ä»»å‹™äº†ã€‚
</thinking>

<attempt_completion>
<result>
å·²å°‡éŠå®¢çš„æœ€å¤§æ•¸é‡å¾ 20 äººèª¿æ•´ç‚º 10 äººã€‚é€™å€‹ä¿®æ”¹æœƒï¼š

1. é™åˆ¶éŠæ¨‚åœ’ä¸­åŒæ™‚å­˜åœ¨çš„æœ€å¤§éŠå®¢æ•¸é‡ç‚º 10 äºº
2. ç•¶éŠå®¢æ•¸é‡é”åˆ° 10 äººæ™‚ï¼Œç³»çµ±æœƒåœæ­¢ç”Ÿæˆæ–°çš„éŠå®¢
3. åªæœ‰ç•¶ç¾æœ‰éŠå®¢é›¢é–‹å¾Œï¼Œæ‰æœƒç”Ÿæˆæ–°çš„éŠå®¢ä»¥ç¶­æŒæœ€å¤§ 10 äººçš„é™åˆ¶

é€™å€‹èª¿æ•´æ‡‰è©²èƒ½è®“éŠæ¨‚åœ’çš„éŠå®¢æ•¸é‡æ›´å®¹æ˜“ç®¡ç†å’Œè§€å¯Ÿã€‚
</result>
</attempt_completion>

---

**User:**

[TASK RESUMPTION] This task was interrupted 4 minutes ago. It may or may not be complete, so please reassess the task context. Be aware that the project state may have changed since then. The current working directory is now '/home/ben/github.com/theme-park-simulator'. If the task has not been completed, retry the last step before interruption and proceed with completing the task.

Note: If you previously attempted a tool use that the user did not provide a result for, you should assume the tool use was not successful and assess whether you should retry. If the last tool was a browser_action, the browser has been closed and you must launch a new browser if needed.

New instructions for task continuation:
<user_message>
èª¿æ•´æ›´æ–°éŠå®¢çš„ fpsï¼Œèª¿ä½ä¸€é»ï¼Œfps å¤§ç´„ 10 å°±å¯ä»¥äº†
</user_message>
<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/components/game/GameCanvas.tsx
src/store/visitorConfigSlice.ts

# Current Time
3/31/2025, 2:21:49 PM (Asia/Taipei, UTC+8:00)

# Current Working Directory (/home/ben/github.com/theme-park-simulator) Files
ğŸ”’ .clineignore
.clinerules
.gitignore
eslint.config.js
index.html
jest.config.ts
jest.setup.ts
package-lock.json
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.test.json
vite.config.ts
cypress/
cypress/fixtures/
cypress/support/
memory-bank/
memory-bank/01_projectbrief.md
memory-bank/02_productContext.md
memory-bank/03_systemPatterns.md
memory-bank/04_techContext.md
memory-bank/05_activeContext.md
memory-bank/06_progress.md
public/
public/vite.svg
src/
src/App.css
src/App.tsx
src/index.css
src/main.tsx
src/vite-env.d.ts
src/assets/
src/assets/react.svg
src/components/
src/components/game/
src/components/game/Facility.ts
src/components/game/FacilityBuilder.ts
src/components/game/GameCanvas.tsx
src/components/game/Visitor.ts
src/components/game/__tests__/
src/components/game/__tests__/Facility.test.ts
src/components/game/__tests__/FacilityBuilder.test.ts
src/components/game/__tests__/Visitor.test.ts
src/components/game/__tests__/Visitor.test.ts.bak
src/components/game/types/
src/components/game/types/FacilityTypes.ts
src/components/game/types/MapConfig.ts
src/components/shared/
src/components/shared/ErrorMessage.css
src/components/shared/ErrorMessage.tsx
src/components/shared/LoadingSpinner.css
src/components/shared/LoadingSpinner.tsx
src/components/shared/Transition.css
src/components/shared/TransitionWrapper.tsx
src/components/ui/
src/components/ui/FacilityBuilderPanel.css
src/components/ui/FacilityBuilderPanel.tsx
src/components/ui/VisitorConfigPanel.tsx
src/components/ui/VisitorInfoPanel.tsx
src/components/ui/__tests__/
src/components/ui/__tests__/FacilityBuilderPanel.test.tsx
src/components/ui/__tests__/VisitorConfigPanel.test.tsx
src/components/ui/__tests__/VisitorInfoPanel.test.tsx
src/engine/
src/hooks/
src/hooks/useAppDispatch.ts
src/hooks/useAppSelector.ts
src/store/
src/store/facilitySlice.ts
src/store/index.ts
src/store/visitorConfigSlice.ts
src/store/visitorSlice.ts
src/types/
src/utils/
src/utils/PathFinder.ts
src/utils/SatisfactionManager.ts
src/utils/__tests__/
src/utils/__tests__/PathFinder.test.ts
src/utils/__tests__/SatisfactionManager.test.ts
tests/
tests/dialog-demo/
tests/dialog-demo/.gitignore
tests/dialog-demo/cypress.config.mjs
tests/dialog-demo/eslint.config.js
tests/dialog-demo/index.html
tests/dialog-demo/package-lock.json
tests/dialog-demo/package.json
tests/dialog-demo/README.md
tests/dialog-demo/tsconfig.app.json
tests/dialog-demo/tsconfig.json
tests/dialog-demo/tsconfig.node.json
tests/dialog-demo/vite.config.ts
tests/dialog-demo/cypress/
tests/dialog-demo/cypress/e2e/
tests/dialog-demo/cypress/e2e/dialog.cy.ts
tests/dialog-demo/cypress/snapshots/
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/dialog-shown.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/initial-state.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/message-1.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/message-2.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/message-3.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/typing-state.png
tests/dialog-demo/cypress/support/
tests/dialog-demo/cypress/support/e2e.ts
tests/dialog-demo/public/
tests/dialog-demo/public/vite.svg
tests/dialog-demo/src/
tests/dialog-demo/src/App.css
tests/dialog-demo/src/App.tsx
tests/dialog-demo/src/index.css
tests/dialog-demo/src/main.tsx
tests/dialog-demo/src/vite-env.d.ts
tests/dialog-demo/src/assets/
tests/dialog-demo/src/assets/react.svg
tests/dialog-demo/src/components/
tests/dialog-demo/src/components/game/
tests/dialog-demo/src/components/game/GameCanvas.tsx
tests/dialog-demo/src/components/ui/
tests/dialog-demo/src/components/ui/DialogInput.tsx
tests/dialog-demo/src/hooks/
tests/dialog-demo/src/hooks/useAppDispatch.ts
tests/dialog-demo/src/hooks/useAppSelector.ts
tests/dialog-demo/src/store/
tests/dialog-demo/src/store/dialogSlice.ts
tests/dialog-demo/src/store/index.ts
tests/dialog-demo/src/utils/

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
ç”¨æˆ¶è¦æ±‚èª¿æ•´éŠå®¢æ›´æ–°çš„ FPS åˆ°å¤§ç´„ 10ã€‚åœ¨ GameCanvas ä¸­ï¼Œæˆ‘å€‘ä½¿ç”¨ requestAnimationFrame ä¾†æ›´æ–°éŠå®¢ç‹€æ…‹ï¼Œç›®å‰çš„æ›´æ–°é »ç‡å¤§ç´„æ˜¯ 60 FPSã€‚æˆ‘å€‘å¯ä»¥é€éè¨ˆç®—æ™‚é–“å·®ä¾†æ§åˆ¶æ›´æ–°é »ç‡ã€‚

è®“æˆ‘æª¢æŸ¥ GameCanvas.tsx ä¸¦ä¿®æ”¹æ›´æ–°é‚è¼¯ã€‚
</thinking>

<replace_in_file>
<path>src/components/game/GameCanvas.tsx</path>
<diff>
<<<<<<< SEARCH
    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // è½‰æ›ç‚ºç§’
      lastTime = currentTime;

      // æ¸…é™¤ç•«å¸ƒ
      context.clearRect(0, 0, width, height);
=======
    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // è½‰æ›ç‚ºç§’
      
      // æ§åˆ¶æ›´æ–°é »ç‡ç‚ºç´„ 10 FPS (100ms é–“éš”)
      if (deltaTime < 0.1) {  // 0.1 ç§’ = 100ms
        animationFrameId = requestAnimationFrame(render);
        return;
      }
      
      lastTime = currentTime;

      // æ¸…é™¤ç•«å¸ƒ
      context.clearRect(0, 0, width, height);
>>>>>>> REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/components/game/GameCanvas.tsx'] Result:
The content was successfully saved to src/components/game/GameCanvas.tsx.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/components/game/GameCanvas.tsx">
import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);
  
  // ä½¿ç”¨ useMemo è¨˜æ†¶åŒ–è¨­æ–½é™£åˆ—
  const facilities = useMemo(() => Object.values(facilitiesMap), [facilitiesMap]);

  // å»ºç«‹éŠå®¢ç”Ÿæˆå‡½æ•¸
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // ä½¿ç”¨è¨˜æ†¶åŒ–çš„ facilities é™£åˆ—æª¢æŸ¥è¨­æ–½è®Šæ›´ä¸¦æ›´æ–° PathFinder
    const obstacles = facilities.map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // åœ¨åœ°åœ–é‚Šç·£éš¨æ©Ÿç”ŸæˆéŠå®¢
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    // å…ˆå°‡éŠå®¢å¯¦ä¾‹åŠ å…¥è¨˜æ†¶é«”ç®¡ç†
    visitorInstancesRef.current.set(newVisitor.id, newVisitor);

    // æ›´æ–° Redux store
    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      prediction: newVisitor.prediction,
      lowSatisfactionCount: newVisitor.lowSatisfactionCount
    }));

    // æ›´æ–°éŠå®¢è¨ˆæ•¸
    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilities]);

  // è¨­ç½®éŠå®¢ç”Ÿæˆå®šæ™‚å™¨
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  // å°‡ visitors ç§»åˆ° useEffect å¤–éƒ¨ä¸¦ä½¿ç”¨ useMemo å„ªåŒ–
  const visitors = useMemo(() => Object.values(visitorsMap), [visitorsMap]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    // è¨­ç½® Canvas çš„å¯¦éš›å¤§å°
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    
    // è¨­ç½® CSS å¤§å°
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    
    // èª¿æ•´æ¯”ä¾‹
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let animationFrameId: number;

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // è½‰æ›ç‚ºç§’
      
      // æ§åˆ¶æ›´æ–°é »ç‡ç‚ºç´„ 10 FPS (100ms é–“éš”)
      if (deltaTime < 0.1) {  // 0.1 ç§’ = 100ms
        animationFrameId = requestAnimationFrame(render);
        return;
      }
      
      lastTime = currentTime;

      // æ¸…é™¤ç•«å¸ƒ
      context.clearRect(0, 0, width, height);

      // ç¹ªè£½ç¶²æ ¼
      drawGrid(context, width, height);
      
      // ç¹ªè£½è¨­æ–½
      facilities.forEach(facility => {
        drawFacility(context, facility);
      });

      // æ›´æ–°ä¸¦ç¹ªè£½æ¯å€‹éŠå®¢
      visitors.forEach((visitor: VisitorInfo) => {
        // ç²å–æˆ–å‰µå»º Visitor å¯¦ä¾‹
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        // æ›´æ–°ç§»å‹•é€Ÿåº¦
        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦è¨­å®šæ–°ç›®æ¨™
        if (visitorInstance.state === VisitorState.IDLE) {
          if (facilities.length > 0) {
            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹è¨­æ–½ä½œç‚ºç›®æ¨™
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        
        // é™åˆ¶æ›´æ–°é »ç‡ï¼Œç´„æ¯ç§’æ›´æ–°ä¸€æ¬¡ç‹€æ…‹
        if (needsUpdate && currentTime % 1000 < 16.7) {
          dispatch(updateVisitor({
            id: visitorInstance.id,
            position: visitorInstance.position,
            state: visitorInstance.state,
            satisfaction: visitorInstance.satisfaction,
            prediction: visitorInstance.prediction,
            lowSatisfactionCount: visitorInstance.lowSatisfactionCount
          }));
        }

        // ç«‹å³ç¹ªè£½éŠå®¢
        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      // å®šæœŸæ¸…ç†éŠå®¢å¯¦ä¾‹ï¼Œè€Œä¸æ˜¯æ¯å¹€éƒ½æ¸…ç†
  if (currentTime % 1000 < 16.7) { // ç´„æ¯ç§’åŸ·è¡Œä¸€æ¬¡
    const currentIds = new Set(visitors.map((v: VisitorInfo) => v.id));
    let deletedCount = 0;
    for (const [id] of visitorInstancesRef.current) {
      if (!currentIds.has(id)) {
        visitorInstancesRef.current.delete(id);
        deletedCount++;
      }
    }
    if (deletedCount > 0) {
      // æ›´æ–°éŠå®¢è¨ˆæ•¸
      setVisitorCount(prev => Math.max(0, prev - deletedCount));
    }
  }

      // è«‹æ±‚ä¸‹ä¸€å¹€
      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilities, visitors, width, height, visitorParams]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    // ç¹ªè£½å‚ç›´ç·š
    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // ç¹ªè£½æ°´å¹³ç·š
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38; // ç•¥å°æ–¼ç¶²æ ¼å¤§å°
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    // æ ¹æ“šè¨­æ–½ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#4CAF50';  // é è¨­ï¼šç‡Ÿé‹ä¸­
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';  // ç¶­è­·ä¸­
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';  // é—œé–‰ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½è¨­æ–½å¤–æ¡†
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    // ç¹ªè£½è¨­æ–½åç¨±
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    // ç¹ªè£½ç­‰å€™äººæ•¸
    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`ç­‰å€™: ${queueLength}äºº`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    // ä¸å†å°‡ä½ç½®å››æ¨äº”å…¥ï¼Œä½¿å‹•ç•«æ›´å¹³æ»‘
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    // å¦‚æœéŠå®¢æ­£åœ¨ç§»å‹•ï¼Œæ·»åŠ å‹•ç•«æ•ˆæœ
    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      // ç¹ªè£½ç§»å‹•è»Œè·¡
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      // æ·»åŠ ç§»å‹•æ–¹å‘æŒ‡ç¤ºå™¨
      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    // æ ¹æ“šéŠå®¢ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#2196F3';   // é è¨­ï¼šéŠè¦½ä¸­
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';   // æ’éšŠä¸­
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';   // éŠç©ä¸­
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';   // é›¢é–‹ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½éŠå®¢åœ–ç¤º
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // ç¹ªè£½éŠå®¢ç‹€æ…‹
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    // ç¹ªè£½æ»¿æ„åº¦æŒ‡æ¨™
    const satisfactionIcon = visitor.satisfaction >= 80 ? 'ğŸ˜Š' : 
                           visitor.satisfaction >= 50 ? 'ğŸ˜' : 'ğŸ˜';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/components/game/GameCanvas.tsx
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/store/visitorConfigSlice.ts

# Current Time
3/31/2025, 2:23:18 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æˆ‘å‰›å‰›å·²ç¶“ä¿®æ”¹äº†éŠæˆ²å¾ªç’°çš„æ›´æ–°é »ç‡ï¼š
1. æ·»åŠ äº†ä¸€å€‹æ™‚é–“é–“éš”æª¢æŸ¥ï¼ˆ0.1ç§’ = 100msï¼‰ï¼Œé€™æœƒå°‡æ›´æ–°é »ç‡é™åˆ¶åœ¨ç´„ 10 FPS
2. å¦‚æœæ™‚é–“é–“éš”å°æ–¼ 0.1 ç§’ï¼Œå‰‡è·³éç•¶å‰æ›´æ–°
3. é€™æ¨£åšæ—¢å¯ä»¥æ¸›å°‘ CPU ä½¿ç”¨ç‡ï¼Œä¹Ÿèƒ½è®“å‹•ç•«æ›´å¹³æ»‘

è®“æˆ‘ç¢ºèªä¸€ä¸‹éŠå®¢ç‹€æ…‹æ›´æ–°çš„é‚è¼¯æ˜¯å¦éœ€è¦èª¿æ•´ã€‚æˆ‘æ³¨æ„åˆ°æˆ‘å€‘åœ¨æ›´æ–°éŠå®¢ç‹€æ…‹æ™‚ä¹Ÿæœ‰ä¸€å€‹é¡ä¼¼çš„é™åˆ¶ï¼š
```typescript
if (needsUpdate && currentTime % 1000 < 16.7)
```
ç‚ºäº†ä¿æŒä¸€è‡´æ€§ï¼Œæˆ‘å€‘ä¹Ÿæ‡‰è©²èª¿æ•´é€™å€‹å€¼ã€‚
</thinking>

<replace_in_file>
<path>src/components/game/GameCanvas.tsx</path>
<diff>
<<<<<<< SEARCH
        // é™åˆ¶æ›´æ–°é »ç‡ï¼Œç´„æ¯ç§’æ›´æ–°ä¸€æ¬¡ç‹€æ…‹
        if (needsUpdate && currentTime % 1000 < 16.7) {
=======
        // é™åˆ¶æ›´æ–°é »ç‡ï¼Œé…åˆ 10 FPS çš„æ›´æ–°é »ç‡
        if (needsUpdate && currentTime % 1000 < 100) {
>>>>>>> REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/components/game/GameCanvas.tsx'] Result:
The content was successfully saved to src/components/game/GameCanvas.tsx.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/components/game/GameCanvas.tsx">
import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);
  
  // ä½¿ç”¨ useMemo è¨˜æ†¶åŒ–è¨­æ–½é™£åˆ—
  const facilities = useMemo(() => Object.values(facilitiesMap), [facilitiesMap]);

  // å»ºç«‹éŠå®¢ç”Ÿæˆå‡½æ•¸
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // ä½¿ç”¨è¨˜æ†¶åŒ–çš„ facilities é™£åˆ—æª¢æŸ¥è¨­æ–½è®Šæ›´ä¸¦æ›´æ–° PathFinder
    const obstacles = facilities.map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // åœ¨åœ°åœ–é‚Šç·£éš¨æ©Ÿç”ŸæˆéŠå®¢
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    // å…ˆå°‡éŠå®¢å¯¦ä¾‹åŠ å…¥è¨˜æ†¶é«”ç®¡ç†
    visitorInstancesRef.current.set(newVisitor.id, newVisitor);

    // æ›´æ–° Redux store
    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      prediction: newVisitor.prediction,
      lowSatisfactionCount: newVisitor.lowSatisfactionCount
    }));

    // æ›´æ–°éŠå®¢è¨ˆæ•¸
    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilities]);

  // è¨­ç½®éŠå®¢ç”Ÿæˆå®šæ™‚å™¨
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  // å°‡ visitors ç§»åˆ° useEffect å¤–éƒ¨ä¸¦ä½¿ç”¨ useMemo å„ªåŒ–
  const visitors = useMemo(() => Object.values(visitorsMap), [visitorsMap]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    // è¨­ç½® Canvas çš„å¯¦éš›å¤§å°
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    
    // è¨­ç½® CSS å¤§å°
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    
    // èª¿æ•´æ¯”ä¾‹
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let animationFrameId: number;

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // è½‰æ›ç‚ºç§’
      
      // æ§åˆ¶æ›´æ–°é »ç‡ç‚ºç´„ 10 FPS (100ms é–“éš”)
      if (deltaTime < 0.1) {  // 0.1 ç§’ = 100ms
        animationFrameId = requestAnimationFrame(render);
        return;
      }
      
      lastTime = currentTime;

      // æ¸…é™¤ç•«å¸ƒ
      context.clearRect(0, 0, width, height);

      // ç¹ªè£½ç¶²æ ¼
      drawGrid(context, width, height);
      
      // ç¹ªè£½è¨­æ–½
      facilities.forEach(facility => {
        drawFacility(context, facility);
      });

      // æ›´æ–°ä¸¦ç¹ªè£½æ¯å€‹éŠå®¢
      visitors.forEach((visitor: VisitorInfo) => {
        // ç²å–æˆ–å‰µå»º Visitor å¯¦ä¾‹
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        // æ›´æ–°ç§»å‹•é€Ÿåº¦
        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦è¨­å®šæ–°ç›®æ¨™
        if (visitorInstance.state === VisitorState.IDLE) {
          if (facilities.length > 0) {
            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹è¨­æ–½ä½œç‚ºç›®æ¨™
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        
        // é™åˆ¶æ›´æ–°é »ç‡ï¼Œé…åˆ 10 FPS çš„æ›´æ–°é »ç‡
        if (needsUpdate && currentTime % 1000 < 100) {
          dispatch(updateVisitor({
            id: visitorInstance.id,
            position: visitorInstance.position,
            state: visitorInstance.state,
            satisfaction: visitorInstance.satisfaction,
            prediction: visitorInstance.prediction,
            lowSatisfactionCount: visitorInstance.lowSatisfactionCount
          }));
        }

        // ç«‹å³ç¹ªè£½éŠå®¢
        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      // å®šæœŸæ¸…ç†éŠå®¢å¯¦ä¾‹ï¼Œè€Œä¸æ˜¯æ¯å¹€éƒ½æ¸…ç†
  if (currentTime % 1000 < 16.7) { // ç´„æ¯ç§’åŸ·è¡Œä¸€æ¬¡
    const currentIds = new Set(visitors.map((v: VisitorInfo) => v.id));
    let deletedCount = 0;
    for (const [id] of visitorInstancesRef.current) {
      if (!currentIds.has(id)) {
        visitorInstancesRef.current.delete(id);
        deletedCount++;
      }
    }
    if (deletedCount > 0) {
      // æ›´æ–°éŠå®¢è¨ˆæ•¸
      setVisitorCount(prev => Math.max(0, prev - deletedCount));
    }
  }

      // è«‹æ±‚ä¸‹ä¸€å¹€
      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilities, visitors, width, height, visitorParams]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    // ç¹ªè£½å‚ç›´ç·š
    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // ç¹ªè£½æ°´å¹³ç·š
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38; // ç•¥å°æ–¼ç¶²æ ¼å¤§å°
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    // æ ¹æ“šè¨­æ–½ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#4CAF50';  // é è¨­ï¼šç‡Ÿé‹ä¸­
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';  // ç¶­è­·ä¸­
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';  // é—œé–‰ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½è¨­æ–½å¤–æ¡†
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    // ç¹ªè£½è¨­æ–½åç¨±
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    // ç¹ªè£½ç­‰å€™äººæ•¸
    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`ç­‰å€™: ${queueLength}äºº`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    // ä¸å†å°‡ä½ç½®å››æ¨äº”å…¥ï¼Œä½¿å‹•ç•«æ›´å¹³æ»‘
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    // å¦‚æœéŠå®¢æ­£åœ¨ç§»å‹•ï¼Œæ·»åŠ å‹•ç•«æ•ˆæœ
    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      // ç¹ªè£½ç§»å‹•è»Œè·¡
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      // æ·»åŠ ç§»å‹•æ–¹å‘æŒ‡ç¤ºå™¨
      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    // æ ¹æ“šéŠå®¢ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#2196F3';   // é è¨­ï¼šéŠè¦½ä¸­
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';   // æ’éšŠä¸­
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';   // éŠç©ä¸­
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';   // é›¢é–‹ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½éŠå®¢åœ–ç¤º
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // ç¹ªè£½éŠå®¢ç‹€æ…‹
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    // ç¹ªè£½æ»¿æ„åº¦æŒ‡æ¨™
    const satisfactionIcon = visitor.satisfaction >= 80 ? 'ğŸ˜Š' : 
                           visitor.satisfaction >= 50 ? 'ğŸ˜' : 'ğŸ˜';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/components/game/GameCanvas.tsx
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/store/visitorConfigSlice.ts

# Current Time
3/31/2025, 2:23:52 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æˆ‘å€‘é‚„éœ€è¦èª¿æ•´éŠå®¢å¯¦ä¾‹æ¸…ç†çš„æ™‚é–“é–“éš”ï¼Œä»¥ä¿æŒæ•´å€‹ç³»çµ±çš„æ›´æ–°é »ç‡ä¸€è‡´ã€‚ç¾åœ¨è®“æˆ‘ä¿®æ”¹æ¸…ç†éŠå®¢å¯¦ä¾‹çš„æ™‚é–“é–“éš”ä¹Ÿæ”¹ç‚º 100msã€‚
</thinking>

<replace_in_file>
<path>src/components/game/GameCanvas.tsx</path>
<diff>
<<<<<<< SEARCH
  if (currentTime % 1000 < 16.7) { // ç´„æ¯ç§’åŸ·è¡Œä¸€æ¬¡
=======
  if (currentTime % 1000 < 100) { // é…åˆ 10 FPS çš„æ›´æ–°é »ç‡
>>>>>>> REPLACE
</diff>
</replace_in_file>

---

**User:**

[replace_in_file for 'src/components/game/GameCanvas.tsx'] Result:
The content was successfully saved to src/components/game/GameCanvas.tsx.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/components/game/GameCanvas.tsx">
import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);
  
  // ä½¿ç”¨ useMemo è¨˜æ†¶åŒ–è¨­æ–½é™£åˆ—
  const facilities = useMemo(() => Object.values(facilitiesMap), [facilitiesMap]);

  // å»ºç«‹éŠå®¢ç”Ÿæˆå‡½æ•¸
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // ä½¿ç”¨è¨˜æ†¶åŒ–çš„ facilities é™£åˆ—æª¢æŸ¥è¨­æ–½è®Šæ›´ä¸¦æ›´æ–° PathFinder
    const obstacles = facilities.map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // åœ¨åœ°åœ–é‚Šç·£éš¨æ©Ÿç”ŸæˆéŠå®¢
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    // å…ˆå°‡éŠå®¢å¯¦ä¾‹åŠ å…¥è¨˜æ†¶é«”ç®¡ç†
    visitorInstancesRef.current.set(newVisitor.id, newVisitor);

    // æ›´æ–° Redux store
    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      prediction: newVisitor.prediction,
      lowSatisfactionCount: newVisitor.lowSatisfactionCount
    }));

    // æ›´æ–°éŠå®¢è¨ˆæ•¸
    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilities]);

  // è¨­ç½®éŠå®¢ç”Ÿæˆå®šæ™‚å™¨
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  // å°‡ visitors ç§»åˆ° useEffect å¤–éƒ¨ä¸¦ä½¿ç”¨ useMemo å„ªåŒ–
  const visitors = useMemo(() => Object.values(visitorsMap), [visitorsMap]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    // è¨­ç½® Canvas çš„å¯¦éš›å¤§å°
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    
    // è¨­ç½® CSS å¤§å°
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    
    // èª¿æ•´æ¯”ä¾‹
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let animationFrameId: number;

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // è½‰æ›ç‚ºç§’
      
      // æ§åˆ¶æ›´æ–°é »ç‡ç‚ºç´„ 10 FPS (100ms é–“éš”)
      if (deltaTime < 0.1) {  // 0.1 ç§’ = 100ms
        animationFrameId = requestAnimationFrame(render);
        return;
      }
      
      lastTime = currentTime;

      // æ¸…é™¤ç•«å¸ƒ
      context.clearRect(0, 0, width, height);

      // ç¹ªè£½ç¶²æ ¼
      drawGrid(context, width, height);
      
      // ç¹ªè£½è¨­æ–½
      facilities.forEach(facility => {
        drawFacility(context, facility);
      });

      // æ›´æ–°ä¸¦ç¹ªè£½æ¯å€‹éŠå®¢
      visitors.forEach((visitor: VisitorInfo) => {
        // ç²å–æˆ–å‰µå»º Visitor å¯¦ä¾‹
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        // æ›´æ–°ç§»å‹•é€Ÿåº¦
        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦è¨­å®šæ–°ç›®æ¨™
        if (visitorInstance.state === VisitorState.IDLE) {
          if (facilities.length > 0) {
            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹è¨­æ–½ä½œç‚ºç›®æ¨™
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        
        // é™åˆ¶æ›´æ–°é »ç‡ï¼Œé…åˆ 10 FPS çš„æ›´æ–°é »ç‡
        if (needsUpdate && currentTime % 1000 < 100) {
          dispatch(updateVisitor({
            id: visitorInstance.id,
            position: visitorInstance.position,
            state: visitorInstance.state,
            satisfaction: visitorInstance.satisfaction,
            prediction: visitorInstance.prediction,
            lowSatisfactionCount: visitorInstance.lowSatisfactionCount
          }));
        }

        // ç«‹å³ç¹ªè£½éŠå®¢
        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      // å®šæœŸæ¸…ç†éŠå®¢å¯¦ä¾‹ï¼Œè€Œä¸æ˜¯æ¯å¹€éƒ½æ¸…ç†
  if (currentTime % 1000 < 100) { // é…åˆ 10 FPS çš„æ›´æ–°é »ç‡
    const currentIds = new Set(visitors.map((v: VisitorInfo) => v.id));
    let deletedCount = 0;
    for (const [id] of visitorInstancesRef.current) {
      if (!currentIds.has(id)) {
        visitorInstancesRef.current.delete(id);
        deletedCount++;
      }
    }
    if (deletedCount > 0) {
      // æ›´æ–°éŠå®¢è¨ˆæ•¸
      setVisitorCount(prev => Math.max(0, prev - deletedCount));
    }
  }

      // è«‹æ±‚ä¸‹ä¸€å¹€
      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilities, visitors, width, height, visitorParams]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    // ç¹ªè£½å‚ç›´ç·š
    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // ç¹ªè£½æ°´å¹³ç·š
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38; // ç•¥å°æ–¼ç¶²æ ¼å¤§å°
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    // æ ¹æ“šè¨­æ–½ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#4CAF50';  // é è¨­ï¼šç‡Ÿé‹ä¸­
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';  // ç¶­è­·ä¸­
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';  // é—œé–‰ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½è¨­æ–½å¤–æ¡†
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    // ç¹ªè£½è¨­æ–½åç¨±
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    // ç¹ªè£½ç­‰å€™äººæ•¸
    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`ç­‰å€™: ${queueLength}äºº`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    // ä¸å†å°‡ä½ç½®å››æ¨äº”å…¥ï¼Œä½¿å‹•ç•«æ›´å¹³æ»‘
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    // å¦‚æœéŠå®¢æ­£åœ¨ç§»å‹•ï¼Œæ·»åŠ å‹•ç•«æ•ˆæœ
    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      // ç¹ªè£½ç§»å‹•è»Œè·¡
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      // æ·»åŠ ç§»å‹•æ–¹å‘æŒ‡ç¤ºå™¨
      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    // æ ¹æ“šéŠå®¢ç‹€æ…‹è¨­ç½®é¡è‰²
    let fillColor = '#2196F3';   // é è¨­ï¼šéŠè¦½ä¸­
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';   // æ’éšŠä¸­
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';   // éŠç©ä¸­
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';   // é›¢é–‹ä¸­
        strokeColor = '#D32F2F';
        break;
    }

    // ç¹ªè£½éŠå®¢åœ–ç¤º
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // ç¹ªè£½éŠå®¢ç‹€æ…‹
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    // ç¹ªè£½æ»¿æ„åº¦æŒ‡æ¨™
    const satisfactionIcon = visitor.satisfaction >= 80 ? 'ğŸ˜Š' : 
                           visitor.satisfaction >= 50 ? 'ğŸ˜' : 'ğŸ˜';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
../../../../144
memory-bank/05_activeContext.md
memory-bank/05_activeContext.md
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/game/Visitor.ts
src/components/game/GameCanvas.tsx
src/store/facilitySlice.ts
src/App.tsx
src/store/visitorSlice.ts
src/store/visitorConfigSlice.ts

# Current Time
3/31/2025, 2:24:27 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
æˆ‘å·²ç¶“å®Œæˆäº†æ‰€æœ‰å¿…è¦çš„æ›´æ–°é »ç‡èª¿æ•´ï¼š

1. ä¸»è¦éŠæˆ²å¾ªç’°æ›´æ–°é »ç‡å¾ 60 FPS é™è‡³ç´„ 10 FPSï¼ˆæ¯ 100ms æ›´æ–°ä¸€æ¬¡ï¼‰
2. éŠå®¢ç‹€æ…‹æ›´æ–°å¾ 16.7ms èª¿æ•´ç‚º 100ms
3. éŠå®¢å¯¦ä¾‹æ¸…ç†å¾ 16.7ms èª¿æ•´ç‚º 100ms

é€™äº›ä¿®æ”¹ä¿æŒäº†æ•´å€‹ç³»çµ±çš„ä¸€è‡´æ€§ï¼Œä¸¦ä¸”æ‡‰è©²èƒ½å¤ é™ä½ CPU ä½¿ç”¨ç‡ã€‚ç¾åœ¨è®“æˆ‘ç¸½çµé€™äº›ä¿®æ”¹ã€‚
</thinking>

<attempt_completion>
<result>
æˆ‘å·²ç¶“èª¿æ•´äº†éŠæˆ²çš„æ›´æ–°é »ç‡ï¼Œä¸»è¦ä¿®æ”¹äº†ä¸‰å€‹éƒ¨åˆ†ï¼š

1. ä¸»è¦éŠæˆ²å¾ªç’°ï¼šå¾ 60 FPS é™ä½åˆ°ç´„ 10 FPSï¼ˆæ¯ 100ms æ›´æ–°ä¸€æ¬¡ï¼‰
2. éŠå®¢ç‹€æ…‹æ›´æ–°ï¼šå¾ 16.7ms æ”¹ç‚º 100ms çš„é–“éš”
3. éŠå®¢å¯¦ä¾‹æ¸…ç†ï¼šå¾ 16.7ms æ”¹ç‚º 100ms çš„é–“éš”

é€™äº›ä¿®æ”¹å°‡ä½¿éŠæˆ²é‹ä½œæ›´æœ‰æ•ˆç‡ï¼Œæ¸›å°‘ä¸å¿…è¦çš„æ›´æ–°ï¼ŒåŒæ™‚ä¿æŒå‹•ç•«çš„æµæš¢æ€§ã€‚ç”±æ–¼éŠæ¨‚åœ’æ¨¡æ“¬ä¸éœ€è¦éå¸¸é«˜çš„æ›´æ–°é »ç‡ï¼Œ10 FPS çš„æ›´æ–°é€Ÿåº¦æ‡‰è©²è¶³å¤ é¡¯ç¤ºéŠå®¢çš„ç§»å‹•å’Œç‹€æ…‹è®ŠåŒ–ã€‚
</result>
</attempt_completion>


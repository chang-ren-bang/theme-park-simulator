**User:**

<task>
只有 增加遊客，畫面上沒有任額設施的時候，不會有問題，遊客可以繼續增加。

但只要畫面上有設施，遊客開始向設施移動，這時任何新增的遊客 都會造成整個動畫效果停住，看起來是有設施的時候 對 遊客清單有異動時會發生問題。
</task>
<environment_details>
# VSCode Visible Files
../../../../830
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/ui/VisitorConfigPanel.tsx
src/store/visitorConfigSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 3:49:46 PM (Asia/Taipei, UTC+8:00)

# Current Working Directory (/home/ben/github.com/theme-park-simulator) Files
🔒 .clineignore
.clinerules
.gitignore
eslint.config.js
index.html
jest.config.ts
jest.setup.ts
package-lock.json
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.test.json
vite.config.ts
cypress/
cypress/fixtures/
cypress/support/
memory-bank/
memory-bank/01_projectbrief.md
memory-bank/02_productContext.md
memory-bank/03_systemPatterns.md
memory-bank/04_techContext.md
memory-bank/05_activeContext.md
memory-bank/06_progress.md
public/
public/vite.svg
src/
src/App.css
src/App.tsx
src/index.css
src/main.tsx
src/vite-env.d.ts
src/assets/
src/assets/react.svg
src/components/
src/components/game/
src/components/game/Facility.ts
src/components/game/FacilityBuilder.ts
src/components/game/GameCanvas.tsx
src/components/game/Visitor.ts
src/components/game/__tests__/
src/components/game/__tests__/Facility.test.ts
src/components/game/__tests__/FacilityBuilder.test.ts
src/components/game/__tests__/Visitor.test.ts
src/components/game/__tests__/Visitor.test.ts.bak
src/components/game/types/
src/components/game/types/FacilityTypes.ts
src/components/game/types/MapConfig.ts
src/components/shared/
src/components/shared/ErrorMessage.css
src/components/shared/ErrorMessage.tsx
src/components/shared/LoadingSpinner.css
src/components/shared/LoadingSpinner.tsx
src/components/shared/Transition.css
src/components/shared/TransitionWrapper.tsx
src/components/ui/
src/components/ui/FacilityBuilderPanel.css
src/components/ui/FacilityBuilderPanel.tsx
src/components/ui/VisitorConfigPanel.tsx
src/components/ui/VisitorInfoPanel.tsx
src/components/ui/__tests__/
src/components/ui/__tests__/FacilityBuilderPanel.test.tsx
src/components/ui/__tests__/VisitorConfigPanel.test.tsx
src/components/ui/__tests__/VisitorInfoPanel.test.tsx
src/engine/
src/hooks/
src/hooks/useAppDispatch.ts
src/hooks/useAppSelector.ts
src/store/
src/store/facilitySlice.ts
src/store/index.ts
src/store/visitorConfigSlice.ts
src/store/visitorSlice.ts
src/types/
src/utils/
src/utils/PathFinder.ts
src/utils/SatisfactionManager.ts
src/utils/__tests__/
src/utils/__tests__/PathFinder.test.ts
src/utils/__tests__/SatisfactionManager.test.ts
tests/
tests/dialog-demo/
tests/dialog-demo/.gitignore
tests/dialog-demo/cypress.config.mjs
tests/dialog-demo/eslint.config.js
tests/dialog-demo/index.html
tests/dialog-demo/package-lock.json
tests/dialog-demo/package.json
tests/dialog-demo/README.md
tests/dialog-demo/tsconfig.app.json
tests/dialog-demo/tsconfig.json
tests/dialog-demo/tsconfig.node.json
tests/dialog-demo/vite.config.ts
tests/dialog-demo/cypress/
tests/dialog-demo/cypress/e2e/
tests/dialog-demo/cypress/e2e/dialog.cy.ts
tests/dialog-demo/cypress/snapshots/
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/dialog-shown.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/initial-state.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/message-1.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/message-2.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/message-3.png
tests/dialog-demo/cypress/snapshots/dialog.cy.ts/typing-state.png
tests/dialog-demo/cypress/support/
tests/dialog-demo/cypress/support/e2e.ts
tests/dialog-demo/public/
tests/dialog-demo/public/vite.svg
tests/dialog-demo/src/
tests/dialog-demo/src/App.css
tests/dialog-demo/src/App.tsx
tests/dialog-demo/src/index.css
tests/dialog-demo/src/main.tsx
tests/dialog-demo/src/vite-env.d.ts
tests/dialog-demo/src/assets/
tests/dialog-demo/src/assets/react.svg
tests/dialog-demo/src/components/
tests/dialog-demo/src/components/game/
tests/dialog-demo/src/components/game/GameCanvas.tsx
tests/dialog-demo/src/components/ui/
tests/dialog-demo/src/components/ui/DialogInput.tsx
tests/dialog-demo/src/hooks/
tests/dialog-demo/src/hooks/useAppDispatch.ts
tests/dialog-demo/src/hooks/useAppSelector.ts
tests/dialog-demo/src/store/
tests/dialog-demo/src/store/dialogSlice.ts
tests/dialog-demo/src/store/index.ts
tests/dialog-demo/src/utils/

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
根據描述，當遊樂園內有設施時，新增遊客時會導致動畫停頓。這聽起來像是效能問題，可能是在更新遊客狀態或位置時產生的。我需要檢查以下幾個檔案來分析問題:

1. GameCanvas.tsx - 因為這裡處理主要的遊戲渲染和更新邏輯
2. Visitor.ts - 檢查遊客的移動和狀態更新邏輯
3. visitorSlice.ts - 檢查 Redux 中遊客狀態的管理方式

讓我先檢查 GameCanvas.tsx，因為這是主要的遊戲循環所在。
</thinking>

<read_file>
<path>src/components/game/GameCanvas.tsx</path>
</read_file>

---

**User:**

[read_file for 'src/components/game/GameCanvas.tsx'] Result:
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);

  // 建立遊客生成函數
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // 檢查設施變更並更新 PathFinder
    const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // 在地圖邊緣隨機生成遊客
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      lowSatisfactionCount: 0
    }));

    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilitiesMap]);

  // 設置遊客生成定時器
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  const visitors = Object.values(visitorsMap);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    // 設置 Canvas 的實際大小
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    
    // 設置 CSS 大小
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    
    // 調整比例
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let lastUpdateTime = performance.now();
    const UPDATE_INTERVAL = 100; // 每 100ms 才更新一次 Redux store
    let animationFrameId: number;

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // 轉換為秒
      lastTime = currentTime;
      const shouldUpdateStore = currentTime - lastUpdateTime >= UPDATE_INTERVAL;

      // 清除畫布
      context.clearRect(0, 0, width, height);

      // 繪製網格
      drawGrid(context, width, height);
      
      // 繪製設施
      Object.values(facilitiesMap).forEach(facility => {
        drawFacility(context, facility);
      });

      // 檢查設施是否有變更
      const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
      const obstaclesHash = JSON.stringify(obstacles);
      
      // 只在設施變更時更新 PathFinder
      if (obstaclesHash !== lastObstaclesHashRef.current) {
        pathFinderRef.current = new PathFinder(1, obstacles);
        lastObstaclesHashRef.current = obstaclesHash;
      }

      // 更新並繪製每個遊客
      visitors.forEach(visitor => {
        // 獲取或創建 Visitor 實例
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        // 更新移動速度
        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        // 檢查是否需要設定新目標
        if (visitorInstance.state === VisitorState.IDLE) {
          const facilities = Object.values(facilitiesMap);
          if (facilities.length > 0) {
            // 隨機選擇一個設施作為目標
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        
        // 只在特定間隔同步回 Redux store
        if (needsUpdate && shouldUpdateStore) {
          dispatch(updateVisitor({
            id: visitorInstance.id,
            position: visitorInstance.position,
            state: visitorInstance.state,
            satisfaction: visitorInstance.satisfaction,
            prediction: visitorInstance.prediction,
            lowSatisfactionCount: visitorInstance.lowSatisfactionCount
          }));
        }

        // 使用最新狀態繪製
        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      if (shouldUpdateStore) {
        lastUpdateTime = currentTime;
      }

      // 清理已不存在的遊客實例
      const currentIds = new Set(visitors.map(v => v.id));
      for (const [id] of visitorInstancesRef.current) {
        if (!currentIds.has(id)) {
          visitorInstancesRef.current.delete(id);
        }
      }

      // 請求下一幀
      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilitiesMap, visitors, width, height, visitorParams]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    // 繪製垂直線
    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // 繪製水平線
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38; // 略小於網格大小
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    // 根據設施狀態設置顏色
    let fillColor = '#4CAF50';  // 預設：營運中
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';  // 維護中
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';  // 關閉中
        strokeColor = '#D32F2F';
        break;
    }

    // 繪製設施外框
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    // 繪製設施名稱
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    // 繪製等候人數
    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`等候: ${queueLength}人`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    // 不再將位置四捨五入，使動畫更平滑
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    // 如果遊客正在移動，添加動畫效果
    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      // 繪製移動軌跡
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      // 添加移動方向指示器
      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    // 根據遊客狀態設置顏色
    let fillColor = '#2196F3';   // 預設：遊覽中
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';   // 排隊中
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';   // 遊玩中
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';   // 離開中
        strokeColor = '#D32F2F';
        break;
    }

    // 繪製遊客圖示
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // 繪製遊客狀態
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    // 繪製滿意度指標
    const satisfactionIcon = visitor.satisfaction >= 80 ? '😊' : 
                           visitor.satisfaction >= 50 ? '😐' : '😞';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

<environment_details>
# VSCode Visible Files
../../../../830
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/ui/VisitorConfigPanel.tsx
src/store/visitorConfigSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 3:49:58 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
在檢視了 GameCanvas.tsx 後，我發現幾個可能導致效能問題的原因：

1. 在 render 函數中，每當新增遊客時，都會進行以下操作：
   - 重新創建遊客實例
   - 檢查並更新 PathFinder
   - 更新 Redux store

2. 主要的效能瓶頸可能來自：
   - PathFinder 的重新創建（當有設施時）
   - 過於頻繁的 Redux store 更新

讓我先檢查 Visitor.ts 來了解遊客的更新邏輯。
</thinking>

<read_file>
<path>src/components/game/Visitor.ts</path>
</read_file>

---

**User:**

[read_file for 'src/components/game/Visitor.ts'] Result:
import { PathFinder, Vector2D } from '../../utils/PathFinder';
import { SatisfactionManager } from '../../utils/SatisfactionManager';

/**
 * 遊客狀態列舉
 */
export enum VisitorState {
  IDLE = 'IDLE',           // 閒置狀態
  MOVING = 'MOVING',       // 移動中
  QUEUING = 'QUEUING',     // 排隊中
  PLAYING = 'PLAYING',     // 遊玩中
  LEAVING = 'LEAVING'      // 準備離開
}

/**
 * 遊客介面
 */
export interface IVisitor {
  id: string;             // 唯一識別碼
  position: Vector2D;     // 當前位置
  state: VisitorState;    // 當前狀態
  satisfaction: number;   // 當前滿意度
  lowSatisfactionCount: number;  // 低滿意度計數器
  prediction?: {
    nextState: VisitorState;      // 預測的下一個狀態
    nextPosition?: Vector2D;      // 預測的下一個位置
    satisfactionTrend: number;    // 預測的滿意度趨勢（正數表示上升，負數表示下降）
    timeToNextState: number;      // 預測到達下一個狀態的時間（秒）
  };
}

/**
 * 遊客類別
 * 管理遊客的行為、狀態和滿意度
 */
export class Visitor implements IVisitor {
  public readonly id: string;
  public position: Vector2D;
  public state: VisitorState;
  public prediction?: {
    nextState: VisitorState;
    nextPosition?: Vector2D;
    satisfactionTrend: number;
    timeToNextState: number;
  };
  
  private pathFinder: PathFinder;
  private satisfactionManager: SatisfactionManager;
  private currentPath: Vector2D[];
  public lowSatisfactionCount: number;
  private lastUpdateTime: number;
  private moveSpeed: number;
  private static readonly SATISFACTION_THRESHOLD = 50;
  private static readonly MAX_LOW_SATISFACTION_COUNT = 3;

  constructor(
    id: string,
    initialPosition: Vector2D,
    pathFinder: PathFinder,
    moveSpeed: number = 2
  ) {
    this.lastUpdateTime = Date.now();
    this.id = id;
    this.moveSpeed = moveSpeed;
    // 確保初始位置為整數
    this.position = {
      x: Math.round(initialPosition.x),
      y: Math.round(initialPosition.y)
    };
    this.state = VisitorState.IDLE;
    this.currentPath = [];
    this.lowSatisfactionCount = 0;

    // 使用共用的路徑尋找器
    this.pathFinder = pathFinder;
    
    // 初始化滿意度管理器
    this.satisfactionManager = new SatisfactionManager();
  }

  /**
   * 設置移動速度
   */
  public setMoveSpeed(speed: number): void {
    this.moveSpeed = speed;
  }

  /**
   * 取得當前滿意度
   */
  public get satisfaction(): number {
    return this.satisfactionManager.getSatisfaction();
  }

  /**
   * 更新遊客位置
   */
  public moveTo(target: Vector2D): void {
    // 重置狀態
    this.state = VisitorState.IDLE;
    this.currentPath = [];

    // 確保目標位置為整數
    const roundedTarget = {
      x: Math.round(target.x),
      y: Math.round(target.y)
    };

    // 檢查目標點與當前位置是否相同
    if (roundedTarget.x === this.position.x && roundedTarget.y === this.position.y) {
      this.state = VisitorState.IDLE;
      this.currentPath = [];
      return;
    }

    // 計算路徑
    const path = this.pathFinder.findPath(this.position, roundedTarget);
    
    // 檢查路徑有效性
    if (!path || path.length === 0 || path.length === 1) {
      this.state = VisitorState.IDLE;
      this.currentPath = [];
      return;
    }

    // 檢查路徑是否真正可達目標
    const lastPoint = path[path.length - 1];
    if (lastPoint.x !== roundedTarget.x || lastPoint.y !== roundedTarget.y) {
      this.state = VisitorState.IDLE;
      this.currentPath = [];
      return;
    }

    // 檢查第一步是否有效
    const firstStep = path[1];
    if (firstStep.x === this.position.x && firstStep.y === this.position.y) {
      this.state = VisitorState.IDLE;
      this.currentPath = [];
      return;
    }

    // 設定移動路徑（排除起點）
    this.currentPath = path.slice(1);
    this.state = VisitorState.MOVING;
  }

  /**
   * 更新遊客狀態
   * @param deltaTime 時間差（秒）
   * @returns 返回是否需要離開遊樂園
   */
  public update(deltaTime: number): boolean {
    this.updatePrediction();
    // 處理移動狀態
    if (this.state === VisitorState.MOVING && this.currentPath.length > 0) {
      const nextPosition = this.currentPath[0];
      const distance = Math.sqrt(
        Math.pow(nextPosition.x - this.position.x, 2) +
        Math.pow(nextPosition.y - this.position.y, 2)
      );

      // 到達檢查和移動邏輯
      const step = Math.min(this.moveSpeed * deltaTime, distance);

      if (step >= distance) {
        // 直接到達目標點
        this.position = { ...nextPosition };
        this.currentPath.shift(); // 移除已到達的點
        
        // 如果路徑清空，轉為閒置狀態
        if (this.currentPath.length === 0) {
          this.state = VisitorState.IDLE;
        }
      } else {
        // 計算並更新新位置
        const ratio = step / distance;
        this.position = {
          x: this.position.x + (nextPosition.x - this.position.x) * ratio,
          y: this.position.y + (nextPosition.y - this.position.y) * ratio
        };
      }
    }

    // 檢查滿意度狀態
    if (this.state !== VisitorState.LEAVING) {
      if (this.satisfactionManager.isBelowThreshold(Visitor.SATISFACTION_THRESHOLD)) {
        this.lowSatisfactionCount++;
        
        if (this.lowSatisfactionCount >= Visitor.MAX_LOW_SATISFACTION_COUNT) {
          this.state = VisitorState.LEAVING;
          return true;
        }
      } else {
        this.lowSatisfactionCount = 0;
      }
    }

    return this.state === VisitorState.LEAVING;
  }

  /**
   * 開始排隊
   */
  public startQueuing(waitingTime: number): void {
    this.state = VisitorState.QUEUING;
    if (waitingTime > 0) {
      const satisfactionDrop = -(waitingTime / 60) * 15;
      this.satisfactionManager.updateSatisfaction(satisfactionDrop);
      
      if (this.satisfaction < Visitor.SATISFACTION_THRESHOLD) {
        this.lowSatisfactionCount++;
      }
    }
  }

  /**
   * 開始遊玩設施
   */
  public startPlaying(): void {
    this.state = VisitorState.PLAYING;
  }

  /**
   * 完成遊玩設施
   */
  public finishPlaying(): void {
    this.satisfactionManager.boostAfterPlay();
    this.state = VisitorState.IDLE;
    
    if (this.satisfaction >= Visitor.SATISFACTION_THRESHOLD) {
      this.lowSatisfactionCount = 0;
    }
  }

  /**
   * 檢查是否需要尋找新的設施
   */
  public needsNewAttraction(): boolean {
    return this.satisfaction < Visitor.SATISFACTION_THRESHOLD;
  }

  /**
   * 更新預測資訊
   */
  private updatePrediction(): void {
    const currentTime = Date.now();
    const timeSinceLastUpdate = (currentTime - this.lastUpdateTime) / 1000;
    
    let nextState = this.state;
    let nextPosition = undefined;
    let satisfactionTrend = 0;
    let timeToNextState = 0;

    switch (this.state) {
      case VisitorState.IDLE:
        nextState = VisitorState.MOVING;
        timeToNextState = 1;
        satisfactionTrend = this.needsNewAttraction() ? -5 : -2;
        break;

      case VisitorState.MOVING:
        if (this.currentPath.length > 0) {
          nextPosition = this.currentPath[0];
          const distance = Math.sqrt(
            Math.pow(nextPosition.x - this.position.x, 2) +
            Math.pow(nextPosition.y - this.position.y, 2)
          );
          nextState = VisitorState.IDLE;
          timeToNextState = distance / this.moveSpeed;
          satisfactionTrend = -2;
        } else {
          nextState = VisitorState.IDLE;
          timeToNextState = 0.5;
          satisfactionTrend = -1;
        }
        break;

      case VisitorState.QUEUING:
        nextState = VisitorState.PLAYING;
        timeToNextState = 5;
        satisfactionTrend = -15;
        break;

      case VisitorState.PLAYING:
        nextState = VisitorState.IDLE;
        timeToNextState = 3;
        satisfactionTrend = 10;
        break;

      case VisitorState.LEAVING:
        satisfactionTrend = -10;
        break;
    }

    this.prediction = {
      nextState,
      nextPosition,
      satisfactionTrend,
      timeToNextState: Math.max(0, timeToNextState - timeSinceLastUpdate)
    };

    this.lastUpdateTime = currentTime;
  }

  /**
   * 用於測試的輔助方法：直接設置滿意度
   */
  public _testSetSatisfaction(value: number): void {
    this.satisfactionManager.updateSatisfaction(value - this.satisfaction);
  }
}

<environment_details>
# VSCode Visible Files
../../../../830
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/ui/VisitorConfigPanel.tsx
src/store/visitorConfigSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 3:50:09 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
我找到了可能的效能問題來源：

1. 在 GameCanvas.tsx 中：
   - 每次渲染時，如果設施位置有變更就重建 PathFinder
   - 遊客列表有變動時會重新創建遊客實例
   - Redux store 的更新頻率可能太高

2. 在 Visitor.ts 中：
   - 每次 update 都會呼叫 updatePrediction
   - 路徑計算可能在有設施時變得複雜

我建議做以下優化：

1. 減少 PathFinder 重建頻率
2. 優化遊客實例管理
3. 降低 Redux store 更新頻率

讓我修改 GameCanvas.tsx：
</thinking>

<replace_in_file>
<path>src/components/game/GameCanvas.tsx</path>
<diff>
<<<<<<< SEARCH
const [visitorInstancesRef] = useState<Map<string, Visitor>>(new Map());
const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
const lastObstaclesHashRef = useRef<string>("");
=======
const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
const lastOb

[Response interrupted by a tool use result. Only one tool may be used at a time and should be placed at the end of the message.]

---

**User:**

[replace_in_file for 'src/components/game/GameCanvas.tsx'] Result:
The tool execution failed with the following error:
<error>
The SEARCH block:
const [visitorInstancesRef] = useState<Map<string, Visitor>>(new Map());
const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
const lastObstaclesHashRef = useRef<string>("");
...does not match anything in the file.

This is likely because the SEARCH block content doesn't match exactly with what's in the file, or if you used multiple SEARCH/REPLACE blocks they may not have been in the order they appear in the file.

The file was reverted to its original state:

<file_content path="src/components/game/GameCanvas.tsx">
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);

  // 建立遊客生成函數
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // 檢查設施變更並更新 PathFinder
    const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // 在地圖邊緣隨機生成遊客
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      lowSatisfactionCount: 0
    }));

    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilitiesMap]);

  // 設置遊客生成定時器
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  const visitors = Object.values(visitorsMap);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    // 設置 Canvas 的實際大小
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    
    // 設置 CSS 大小
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    
    // 調整比例
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let lastUpdateTime = performance.now();
    const UPDATE_INTERVAL = 100; // 每 100ms 才更新一次 Redux store
    let animationFrameId: number;

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // 轉換為秒
      lastTime = currentTime;
      const shouldUpdateStore = currentTime - lastUpdateTime >= UPDATE_INTERVAL;

      // 清除畫布
      context.clearRect(0, 0, width, height);

      // 繪製網格
      drawGrid(context, width, height);
      
      // 繪製設施
      Object.values(facilitiesMap).forEach(facility => {
        drawFacility(context, facility);
      });

      // 檢查設施是否有變更
      const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
      const obstaclesHash = JSON.stringify(obstacles);
      
      // 只在設施變更時更新 PathFinder
      if (obstaclesHash !== lastObstaclesHashRef.current) {
        pathFinderRef.current = new PathFinder(1, obstacles);
        lastObstaclesHashRef.current = obstaclesHash;
      }

      // 更新並繪製每個遊客
      visitors.forEach(visitor => {
        // 獲取或創建 Visitor 實例
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        // 更新移動速度
        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        // 檢查是否需要設定新目標
        if (visitorInstance.state === VisitorState.IDLE) {
          const facilities = Object.values(facilitiesMap);
          if (facilities.length > 0) {
            // 隨機選擇一個設施作為目標
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        
        // 只在特定間隔同步回 Redux store
        if (needsUpdate && shouldUpdateStore) {
          dispatch(updateVisitor({
            id: visitorInstance.id,
            position: visitorInstance.position,
            state: visitorInstance.state,
            satisfaction: visitorInstance.satisfaction,
            prediction: visitorInstance.prediction,
            lowSatisfactionCount: visitorInstance.lowSatisfactionCount
          }));
        }

        // 使用最新狀態繪製
        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      if (shouldUpdateStore) {
        lastUpdateTime = currentTime;
      }

      // 清理已不存在的遊客實例
      const currentIds = new Set(visitors.map(v => v.id));
      for (const [id] of visitorInstancesRef.current) {
        if (!currentIds.has(id)) {
          visitorInstancesRef.current.delete(id);
        }
      }

      // 請求下一幀
      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilitiesMap, visitors, width, height, visitorParams]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    // 繪製垂直線
    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // 繪製水平線
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38; // 略小於網格大小
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    // 根據設施狀態設置顏色
    let fillColor = '#4CAF50';  // 預設：營運中
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';  // 維護中
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';  // 關閉中
        strokeColor = '#D32F2F';
        break;
    }

    // 繪製設施外框
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    // 繪製設施名稱
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    // 繪製等候人數
    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`等候: ${queueLength}人`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    // 不再將位置四捨五入，使動畫更平滑
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    // 如果遊客正在移動，添加動畫效果
    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      // 繪製移動軌跡
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      // 添加移動方向指示器
      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    // 根據遊客狀態設置顏色
    let fillColor = '#2196F3';   // 預設：遊覽中
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';   // 排隊中
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';   // 遊玩中
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';   // 離開中
        strokeColor = '#D32F2F';
        break;
    }

    // 繪製遊客圖示
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // 繪製遊客狀態
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    // 繪製滿意度指標
    const satisfactionIcon = visitor.satisfaction >= 80 ? '😊' : 
                           visitor.satisfaction >= 50 ? '😐' : '😞';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

</file_content>

Try again with fewer/more precise SEARCH blocks.
(If you run into this error two times in a row, you may use the write_to_file tool as a fallback.)
</error>
<environment_details>
# VSCode Visible Files
../../../../830
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/ui/VisitorConfigPanel.tsx
src/store/visitorConfigSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 3:50:27 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
我重新檢視了代碼，讓我使用更精確的 SEARCH/REPLACE 來修改檔案。主要優化重點：

1. 減少 PathFinder 重建的頻率
2. 避免不必要的狀態更新
3. 優化遊客實例的管理和更新邏輯
</thinking>

<replace_in_file>
<path>src/components/game/GameCanvas.tsx</path>
<diff>
<<<<<<< SEARCH
  // 檢查設施變更並更新 PathFinder
    const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }
=======
    // 使用現有的 PathFinder
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );
>>>>>>> REPLACE

<<<<<<< SEARCH
      // 檢查設施是否有變更
      const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
      const obstaclesHash = JSON.stringify(obstacles);
      
      // 只在設施變更時更新 PathFinder
      if (obstaclesHash !== lastObstaclesHashRef.current) {
        pathFinderRef.current = new PathFinder(1, obstacles);
        lastObstaclesHashRef.current = obstaclesHash;
      }
=======
      // 檢查並暫存設施變更
      const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
      const obstaclesHash = JSON.stringify(obstacles);
      
      // 每秒最多更新一次 PathFinder
      const now = performance.now();
      if (obstaclesHash !== lastObstaclesHashRef.current && (!lastPathFinderUpdateTime || now - lastPathFinderUpdateTime >= 1000)) {
        pathFinderRef.current = new PathFinder(1, obstacles);
        lastObstaclesHashRef.current = obstaclesHash;
        lastPathFinderUpdateTime = now;
      }
>>>>>>> REPLACE

<<<<<<< SEARCH
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
=======
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstac

[Response interrupted by a tool use result. Only one tool may be used at a time and should be placed at the end of the message.]

---

**User:**

[replace_in_file for 'src/components/game/GameCanvas.tsx'] Result:
The tool execution failed with the following error:
<error>
The SEARCH block:
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
...does not match anything in the file.

This is likely because the SEARCH block content doesn't match exactly with what's in the file, or if you used multiple SEARCH/REPLACE blocks they may not have been in the order they appear in the file.

The file was reverted to its original state:

<file_content path="src/components/game/GameCanvas.tsx">
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);

  // 建立遊客生成函數
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // 檢查設施變更並更新 PathFinder
    const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
    const obstaclesHash = JSON.stringify(obstacles);
    
    if (obstaclesHash !== lastObstaclesHashRef.current) {
      pathFinderRef.current = new PathFinder(1, obstacles);
      lastObstaclesHashRef.current = obstaclesHash;
    }

    // 在地圖邊緣隨機生成遊客
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      lowSatisfactionCount: 0
    }));

    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed, facilitiesMap]);

  // 設置遊客生成定時器
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  const visitors = Object.values(visitorsMap);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    // 設置 Canvas 的實際大小
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    
    // 設置 CSS 大小
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    
    // 調整比例
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let lastUpdateTime = performance.now();
    const UPDATE_INTERVAL = 100; // 每 100ms 才更新一次 Redux store
    let animationFrameId: number;

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;  // 轉換為秒
      lastTime = currentTime;
      const shouldUpdateStore = currentTime - lastUpdateTime >= UPDATE_INTERVAL;

      // 清除畫布
      context.clearRect(0, 0, width, height);

      // 繪製網格
      drawGrid(context, width, height);
      
      // 繪製設施
      Object.values(facilitiesMap).forEach(facility => {
        drawFacility(context, facility);
      });

      // 檢查設施是否有變更
      const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
      const obstaclesHash = JSON.stringify(obstacles);
      
      // 只在設施變更時更新 PathFinder
      if (obstaclesHash !== lastObstaclesHashRef.current) {
        pathFinderRef.current = new PathFinder(1, obstacles);
        lastObstaclesHashRef.current = obstaclesHash;
      }

      // 更新並繪製每個遊客
      visitors.forEach(visitor => {
        // 獲取或創建 Visitor 實例
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        // 更新移動速度
        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        // 檢查是否需要設定新目標
        if (visitorInstance.state === VisitorState.IDLE) {
          const facilities = Object.values(facilitiesMap);
          if (facilities.length > 0) {
            // 隨機選擇一個設施作為目標
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        
        // 只在特定間隔同步回 Redux store
        if (needsUpdate && shouldUpdateStore) {
          dispatch(updateVisitor({
            id: visitorInstance.id,
            position: visitorInstance.position,
            state: visitorInstance.state,
            satisfaction: visitorInstance.satisfaction,
            prediction: visitorInstance.prediction,
            lowSatisfactionCount: visitorInstance.lowSatisfactionCount
          }));
        }

        // 使用最新狀態繪製
        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      if (shouldUpdateStore) {
        lastUpdateTime = currentTime;
      }

      // 清理已不存在的遊客實例
      const currentIds = new Set(visitors.map(v => v.id));
      for (const [id] of visitorInstancesRef.current) {
        if (!currentIds.has(id)) {
          visitorInstancesRef.current.delete(id);
        }
      }

      // 請求下一幀
      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilitiesMap, visitors, width, height, visitorParams]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    // 繪製垂直線
    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    // 繪製水平線
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38; // 略小於網格大小
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    // 根據設施狀態設置顏色
    let fillColor = '#4CAF50';  // 預設：營運中
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';  // 維護中
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';  // 關閉中
        strokeColor = '#D32F2F';
        break;
    }

    // 繪製設施外框
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    // 繪製設施名稱
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    // 繪製等候人數
    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`等候: ${queueLength}人`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    // 不再將位置四捨五入，使動畫更平滑
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    // 如果遊客正在移動，添加動畫效果
    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      // 繪製移動軌跡
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      // 添加移動方向指示器
      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    // 根據遊客狀態設置顏色
    let fillColor = '#2196F3';   // 預設：遊覽中
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';   // 排隊中
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';   // 遊玩中
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';   // 離開中
        strokeColor = '#D32F2F';
        break;
    }

    // 繪製遊客圖示
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    // 繪製遊客狀態
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    // 繪製滿意度指標
    const satisfactionIcon = visitor.satisfaction >= 80 ? '😊' : 
                           visitor.satisfaction >= 50 ? '😐' : '😞';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

</file_content>

Try again with fewer/more precise SEARCH blocks.
(If you run into this error two times in a row, you may use the write_to_file tool as a fallback.)
</error>
<environment_details>
# VSCode Visible Files
../../../../830
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/ui/VisitorConfigPanel.tsx
src/store/visitorConfigSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 3:50:53 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
由於 replace_in_file 出現錯誤，讓我使用 write_to_file 來完整更新檔案內容。主要的優化包括：

1. 新增 lastPathFinderUpdateTime 來限制 PathFinder 更新頻率
2. 減少不必要的狀態更新
3. 優化遊客實例的創建和更新邏輯
4. 提高 UPDATE_INTERVAL 以減少 Redux store 更新頻率
</thinking>

<write_to_file>
<path>src/components/game/GameCanvas.tsx</path>
<content>
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  const lastPathFinderUpdateTime = useRef<number>(0);
  const batchUpdateTimerRef = useRef<number | null>(null);
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);

  // 建立遊客生成函數
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // 在地圖邊緣隨機生成遊客
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      lowSatisfactionCount: 0
    }));

    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed]);

  // 設置遊客生成定時器
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  const visitors = Object.values(visitorsMap);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  // 批次更新 Redux store
  const batchUpdateStore = useCallback((updates: Array<{ visitor: Visitor, needsUpdate: boolean }>) => {
    updates.forEach(({ visitor, needsUpdate }) => {
      if (needsUpdate) {
        dispatch(updateVisitor({
          id: visitor.id,
          position: visitor.position,
          state: visitor.state,
          satisfaction: visitor.satisfaction,
          prediction: visitor.prediction,
          lowSatisfactionCount: visitor.lowSatisfactionCount
        }));
      }
    });
  }, [dispatch]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let lastUpdateTime = performance.now();
    const UPDATE_INTERVAL = 200; // 增加更新間隔到 200ms
    let animationFrameId: number;
    const pendingUpdates: Array<{ visitor: Visitor, needsUpdate: boolean }> = [];

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      const shouldUpdateStore = currentTime - lastUpdateTime >= UPDATE_INTERVAL;

      // 清除畫布和繪製基本元素
      context.clearRect(0, 0, width, height);
      drawGrid(context, width, height);
      Object.values(facilitiesMap).forEach(facility => {
        drawFacility(context, facility);
      });

      // 檢查並更新 PathFinder（限制更新頻率）
      const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
      const obstaclesHash = JSON.stringify(obstacles);
      
      if (obstaclesHash !== lastObstaclesHashRef.current && 
          currentTime - lastPathFinderUpdateTime.current >= 1000) {
        pathFinderRef.current = new PathFinder(1, obstacles);
        lastObstaclesHashRef.current = obstaclesHash;
        lastPathFinderUpdateTime.current = currentTime;
      }

      // 更新並繪製遊客
      pendingUpdates.length = 0;
      
      visitors.forEach(visitor => {
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        if (visitorInstance.state === VisitorState.IDLE) {
          const facilities = Object.values(facilitiesMap);
          if (facilities.length > 0) {
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        if (shouldUpdateStore) {
          pendingUpdates.push({ visitor: visitorInstance, needsUpdate });
        }

        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      if (shouldUpdateStore) {
        lastUpdateTime = currentTime;
        if (pendingUpdates.length > 0) {
          if (batchUpdateTimerRef.current !== null) {
            cancelAnimationFrame(batchUpdateTimerRef.current);
          }
          batchUpdateTimerRef.current = requestAnimationFrame(() => {
            batchUpdateStore(pendingUpdates);
            batchUpdateTimerRef.current = null;
          });
        }
      }

      // 清理不存在的遊客實例
      const currentIds = new Set(visitors.map(v => v.id));
      for (const [id] of visitorInstancesRef.current) {
        if (!currentIds.has(id)) {
          visitorInstancesRef.current.delete(id);
        }
      }

      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      if (batchUpdateTimerRef.current !== null) {
        cancelAnimationFrame(batchUpdateTimerRef.current);
      }
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilitiesMap, visitors, width, height, visitorParams, batchUpdateStore]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38;
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    let fillColor = '#4CAF50';
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';
        strokeColor = '#D32F2F';
        break;
    }

    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`等候: ${queueLength}人`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    let fillColor = '#2196F3';
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';
        strokeColor = '#D32F2F';
        break;
    }

    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    const satisfactionIcon = visitor.satisfaction >= 80 ? '😊' : 
                           visitor.satisfaction >= 50 ? '😐' : '😞';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;
</content>
</write_to_file>

---

**User:**

[write_to_file for 'src/components/game/GameCanvas.tsx'] Result:
The content was successfully saved to src/components/game/GameCanvas.tsx.

Here is the full, updated content of the file that was saved:

<final_file_content path="src/components/game/GameCanvas.tsx">
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useAppSelector } from '../../hooks/useAppSelector';
import { useAppDispatch } from '../../hooks/useAppDispatch';
import { Facility } from './Facility';
import type { IVisitor as VisitorInfo } from './Visitor';
import { Visitor, VisitorState } from './Visitor';
import { FacilityStatus } from './types/FacilityTypes';
import { selectVisitorParams } from '../../store/visitorConfigSlice';
import { updateVisitor } from '../../store/visitorSlice';
import { PathFinder } from '../../utils/PathFinder';

interface GameCanvasProps {
  width?: number;
  height?: number;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ 
  width = 800, 
  height = 600 
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const dispatch = useAppDispatch();
  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);
  const [visitorCount, setVisitorCount] = useState(0);
  const visitorInstancesRef = useRef<Map<string, Visitor>>(new Map());
  const pathFinderRef = useRef<PathFinder>(new PathFinder(1, []));
  const lastObstaclesHashRef = useRef<string>("");
  const lastPathFinderUpdateTime = useRef<number>(0);
  const batchUpdateTimerRef = useRef<number | null>(null);
  
  const facilitiesMap = useAppSelector(state => state.facilities.facilities);
  const visitorsMap = useAppSelector(state => state.visitors.visitors);
  const visitorParams = useAppSelector(selectVisitorParams);

  // 建立遊客生成函數
  const spawnVisitor = useCallback(() => {
    if (visitorCount >= visitorParams.totalVisitors) return;

    // 在地圖邊緣隨機生成遊客
    const spawnPoints = [
      { x: 0, y: Math.floor(Math.random() * 15) },
      { x: 19, y: Math.floor(Math.random() * 15) },
      { x: Math.floor(Math.random() * 20), y: 0 },
      { x: Math.floor(Math.random() * 20), y: 14 }
    ];
    
    const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    const newVisitor = new Visitor(
      `visitor_${Date.now()}`,
      spawnPoint,
      pathFinderRef.current,
      visitorParams.moveSpeed
    );

    dispatch(updateVisitor({
      id: newVisitor.id,
      position: newVisitor.position,
      state: newVisitor.state,
      satisfaction: newVisitor.satisfaction,
      lowSatisfactionCount: 0
    }));

    setVisitorCount(prev => prev + 1);
  }, [dispatch, visitorCount, visitorParams.totalVisitors, visitorParams.moveSpeed]);

  // 設置遊客生成定時器
  useEffect(() => {
    const spawnTimer = setInterval(spawnVisitor, visitorParams.spawnInterval);
    return () => clearInterval(spawnTimer);
  }, [spawnVisitor, visitorParams.spawnInterval]);

  const visitors = Object.values(visitorsMap);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    setContext(ctx);

    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  }, [width, height]);

  // 批次更新 Redux store
  const batchUpdateStore = useCallback((updates: Array<{ visitor: Visitor, needsUpdate: boolean }>) => {
    updates.forEach(({ visitor, needsUpdate }) => {
      if (needsUpdate) {
        dispatch(updateVisitor({
          id: visitor.id,
          position: visitor.position,
          state: visitor.state,
          satisfaction: visitor.satisfaction,
          prediction: visitor.prediction,
          lowSatisfactionCount: visitor.lowSatisfactionCount
        }));
      }
    });
  }, [dispatch]);

  useEffect(() => {
    if (!context) return;

    let lastTime = performance.now();
    let lastUpdateTime = performance.now();
    const UPDATE_INTERVAL = 200; // 增加更新間隔到 200ms
    let animationFrameId: number;
    const pendingUpdates: Array<{ visitor: Visitor, needsUpdate: boolean }> = [];

    const render = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      const shouldUpdateStore = currentTime - lastUpdateTime >= UPDATE_INTERVAL;

      // 清除畫布和繪製基本元素
      context.clearRect(0, 0, width, height);
      drawGrid(context, width, height);
      Object.values(facilitiesMap).forEach(facility => {
        drawFacility(context, facility);
      });

      // 檢查並更新 PathFinder（限制更新頻率）
      const obstacles = Object.values(facilitiesMap).map(f => f.getPosition());
      const obstaclesHash = JSON.stringify(obstacles);
      
      if (obstaclesHash !== lastObstaclesHashRef.current && 
          currentTime - lastPathFinderUpdateTime.current >= 1000) {
        pathFinderRef.current = new PathFinder(1, obstacles);
        lastObstaclesHashRef.current = obstaclesHash;
        lastPathFinderUpdateTime.current = currentTime;
      }

      // 更新並繪製遊客
      pendingUpdates.length = 0;
      
      visitors.forEach(visitor => {
        let visitorInstance = visitorInstancesRef.current.get(visitor.id);
        if (!visitorInstance) {
          visitorInstance = new Visitor(
            visitor.id,
            visitor.position,
            pathFinderRef.current,
            visitorParams.moveSpeed
          );
          visitorInstancesRef.current.set(visitor.id, visitorInstance);
        }

        visitorInstance.setMoveSpeed(visitorParams.moveSpeed);
        
        if (visitorInstance.state === VisitorState.IDLE) {
          const facilities = Object.values(facilitiesMap);
          if (facilities.length > 0) {
            const targetFacility = facilities[Math.floor(Math.random() * facilities.length)];
            visitorInstance.moveTo(targetFacility.getPosition());
          }
        }

        const needsUpdate = visitorInstance.update(deltaTime);
        if (shouldUpdateStore) {
          pendingUpdates.push({ visitor: visitorInstance, needsUpdate });
        }

        drawVisitor(context, {
          ...visitor,
          position: visitorInstance.position,
          state: visitorInstance.state,
          satisfaction: visitorInstance.satisfaction,
          prediction: visitorInstance.prediction,
          lowSatisfactionCount: visitorInstance.lowSatisfactionCount
        });
      });

      if (shouldUpdateStore) {
        lastUpdateTime = currentTime;
        if (pendingUpdates.length > 0) {
          if (batchUpdateTimerRef.current !== null) {
            cancelAnimationFrame(batchUpdateTimerRef.current);
          }
          batchUpdateTimerRef.current = requestAnimationFrame(() => {
            batchUpdateStore(pendingUpdates);
            batchUpdateTimerRef.current = null;
          });
        }
      }

      // 清理不存在的遊客實例
      const currentIds = new Set(visitors.map(v => v.id));
      for (const [id] of visitorInstancesRef.current) {
        if (!currentIds.has(id)) {
          visitorInstancesRef.current.delete(id);
        }
      }

      animationFrameId = requestAnimationFrame(render);
    };

    render(performance.now());

    return () => {
      if (batchUpdateTimerRef.current !== null) {
        cancelAnimationFrame(batchUpdateTimerRef.current);
      }
      cancelAnimationFrame(animationFrameId);
    };
  }, [context, facilitiesMap, visitors, width, height, visitorParams, batchUpdateStore]);

  const drawGrid = (
    ctx: CanvasRenderingContext2D, 
    w: number, 
    h: number
  ) => {
    const gridSize = 40;
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;

    for (let x = 0; x <= w; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }

    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }
  };

  const drawFacility = (
    ctx: CanvasRenderingContext2D, 
    facility: Facility,
  ) => {
    const size = 38;
    const position = facility.getPosition();
    const x = position.x * 40 + 1;
    const y = position.y * 40 + 1;

    let fillColor = '#4CAF50';
    let strokeColor = '#388E3C';
    
    switch(facility.getStatus()) {
      case FacilityStatus.MAINTENANCE:
        fillColor = '#FFC107';
        strokeColor = '#FFA000';
        break;
      case FacilityStatus.CLOSED:
        fillColor = '#F44336';
        strokeColor = '#D32F2F';
        break;
    }

    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x, y, size, size);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(facility.getName(), x + size/2, y + size/2 - 8);

    const queueLength = facility.getQueueLength();
    if (queueLength > 0) {
      ctx.fillStyle = '#fff';
      ctx.font = '10px Arial';
      ctx.fillText(`等候: ${queueLength}人`, x + size/2, y + size/2 + 8);
    }
  };

  const drawVisitor = (
    ctx: CanvasRenderingContext2D, 
    visitor: VisitorInfo
  ) => {
    const radius = 10;
    const x = visitor.position.x * 40 + 20;
    const y = visitor.position.y * 40 + 20;

    if (visitor.state === VisitorState.MOVING && visitor.prediction?.nextPosition) {
      ctx.save();
      
      ctx.strokeStyle = '#2196F3';
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(
        visitor.prediction.nextPosition.x * 40 + 20,
        visitor.prediction.nextPosition.y * 40 + 20
      );
      ctx.stroke();

      const dx = visitor.prediction.nextPosition.x * 40 + 20 - x;
      const dy = visitor.prediction.nextPosition.y * 40 + 20 - y;
      const angle = Math.atan2(dy, dx);
      
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(radius + 5, 0);
      ctx.lineTo(radius + 12, -4);
      ctx.lineTo(radius + 12, 4);
      ctx.closePath();
      ctx.fillStyle = '#2196F3';
      ctx.fill();
      
      ctx.restore();
    }

    let fillColor = '#2196F3';
    let strokeColor = '#1976D2';
    
    switch(visitor.state) {
      case VisitorState.QUEUING:
        fillColor = '#FF9800';
        strokeColor = '#F57C00';
        break;
      case VisitorState.PLAYING:
        fillColor = '#4CAF50';
        strokeColor = '#388E3C';
        break;
      case VisitorState.LEAVING:
        fillColor = '#F44336';
        strokeColor = '#D32F2F';
        break;
    }

    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(visitor.state, x, y - 15);

    const satisfactionIcon = visitor.satisfaction >= 80 ? '😊' : 
                           visitor.satisfaction >= 50 ? '😐' : '😞';
    ctx.font = '12px Arial';
    ctx.fillText(satisfactionIcon, x, y + 15);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        borderRadius: '4px',
        backgroundColor: '#fff'
      }}
    />
  );
};

export default GameCanvas;

</final_file_content>

IMPORTANT: For any future changes to this file, use the final_file_content shown above as your reference. This content reflects the current state of the file, including any auto-formatting (e.g., if you used single quotes but the formatter converted them to double quotes). Always base your SEARCH/REPLACE operations on this final version to ensure accuracy.


<environment_details>
# VSCode Visible Files
../../../../830
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx
src/components/game/GameCanvas.tsx

# VSCode Open Tabs
src/components/ui/VisitorConfigPanel.tsx
src/store/visitorConfigSlice.ts
src/components/game/GameCanvas.tsx

# Current Time
3/31/2025, 3:52:28 PM (Asia/Taipei, UTC+8:00)

# Current Mode
ACT MODE
</environment_details>

---

**Assistant:**

<thinking>
我已經完成了以下優化：

1. 減少 PathFinder 更新頻率：
   - 新增 lastPathFinderUpdateTime 來限制更新頻率為每秒最多一次
   - 移除了 spawnVisitor 中的 PathFinder 檢查

2. 優化 Redux store 更新：
   - 增加更新間隔從 100ms 到 200ms
   - 引入批次更新機制，使用 batchUpdateStore
   - 使用 pendingUpdates 陣列來收集需要更新的變更

3. 優化遊客實例管理：
   - 保持 Visitor 實例的重用
   - 只在必要時更新 Redux store

4. 改善記憶體管理：
   - 添加了 batchUpdateTimerRef 來正確清理批次更新計時器
   - 優化了遊客實例的清理機制

這些修改應該可以解決當有設施時新增遊客造成動畫停頓的問題。
</thinking>

<attempt_completion>
<result>
已完成效能優化，主要改進包括：

1. 限制 PathFinder 更新頻率，避免頻繁重建
2. 實作批次更新機制，減少 Redux store 更新頻率
3. 優化遊客實例的管理和重用
4. 改善記憶體管理，避免記憶體洩漏

這些優化應該能夠解決在有設施時新增遊客導致動畫停頓的問題。系統現在應該能夠更平滑地處理遊客的新增和移動。
</result>
</attempt_completion>

